// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1414868997000,
    "title": "Dependent select box",
    "slug": "dependent-select-box"
  },
  "body": "<p>Občas je v Nette zapotřebí vyřešit dependent select box. Je to relativně málo častý požadavek a o to méně se o něm dá najít, když je to zrovna potřeba. V zásadě existují dvě řešení. Nudné - poctivé a pak zábavné - špinavé. Podívejme se na to, jak se dá takový dependent select box jednoduše vyřešit.</p>\n<h2 id=\"-ist-e-en-\">Čisté řešení <a href=\"#-ist-e-en-\">#</a></h2><p><img src=\"https://zlmlcz-media.s3-eu-west-1.amazonaws.com/51d212f2-5aa9-44b9-9085-f6267e1974e9/vystrizek.png\" alt=\"\">\nToto řešení ukazuje jak by se takový problém měl zhruba řešit. Myšlenka je velmi jednoduchá. Prvně potřebujeme data do závislého select boxu. Ty se normálně vyřeší prostřednistvím databáze, v našem případě postačí jednoduché pole.</p>\n<pre><code class=\"lang-php\">private $database = [\n    [1 =&gt; &#39;2&#39;, &#39;4&#39;, &#39;9&#39;],\n    [4 =&gt; &#39;.&#39;, &#39;∴&#39;, &#39;…&#39;],\n    [5 =&gt; &#39;π&#39;, &#39;€&#39;, &#39;©&#39;],\n];\n</code></pre>\n<p>Následně je potřeba vytvořit samotný formulář:</p>\n<pre><code class=\"lang-php\">protected function createComponentForm($name) {\n    $form = new UI\\Form;\n    $this[$name] = $form; // &lt;- Zde je celý fígl\n\n    $form-&gt;addSelect(&#39;one&#39;, &#39;One&#39;, [&#39;Čísla&#39;, &#39;Tečky&#39;, &#39;Symboly&#39;])-&gt;setDefaultValue(1);\n    //dump($form[&#39;one&#39;]-&gt;value);\n\n    $form-&gt;addSelect(&#39;two&#39;, &#39;Two&#39;, $this-&gt;database[$form[&#39;one&#39;]-&gt;value]);\n\n    $form-&gt;addSubmit(&#39;send&#39;, &#39;Odeslat&#39;);\n    $form-&gt;onSuccess[] = $this-&gt;success;\n    return $form;\n}\n</code></pre>\n<p>A k formuláři také šablonu:</p>\n<pre><code class=\"lang-html\">{form form}\n    {input one, size =&gt; 3}\n    {snippet two}\n        {input two, size =&gt; 3}\n    {/snippet}\n    {input send}\n{/form}\n</code></pre>\n<p>Aby šlo použít snippet uvnitř formulářového makra, budeme muset udělat malý workaround:</p>\n<pre><code class=\"lang-php\">public function beforeRender() {\n    parent::beforeRender();\n    $this-&gt;template-&gt;_form = $this[&#39;form&#39;]; // form {snippet} workaround\n}\n</code></pre>\n<p>Snippet je však možné zatím úplně vynechat, protože bude potřeba až při ajaxifikaci.</p>\n<p>Celý fígl je v tom, že musíme zajistit, aby se hodnota druhého select boxu nastavovala podle hodnoty prvního. V tomto stavu je již možné formulář spustit. Po vybrání v prvním select boxu a odeslání formuláře se vybraná hodnota následně projeví v druhém select boxu. Celé kouzlo je pouze v té druhé řádce formulářové továrničky, který mi umožní přistoupit k hodnotám prvků. Je samozřejmě nesmysl odesílat celý formulář pro získání obsahu druhého select boxu, proto si napíšeme krátký javascriptový kód, který to za nás vyřeší (nette.ajax.js):</p>\n<pre><code class=\"lang-javascript\">$(function(){\n    $.nette.init();\n\n    $(&#39;select[name=one]&#39;).change(function () {\n        $.nette.ajax({\n            url: {link invalidate!},\n            data: {\n                &#39;value&#39;: $(&#39;select[name=one]&#39;).val(),\n            }\n        });\n    });\n});\n</code></pre>\n<p>Jakmile se změní hodnota prvního select boxu, zavoláme si handler a předáme mu novou hodnotu. Tento handler bude mít za úkol nastavit hodnoty druhého select boxu a pouze tento prvek invalidovat:</p>\n<pre><code class=\"lang-php\">public function handleInvalidate($value) {\n    $this[&#39;form&#39;][&#39;two&#39;]-&gt;setItems($this-&gt;database[$value]);\n    $this-&gt;redrawControl(&#39;two&#39;);\n}\n</code></pre>\n<p>Tím je vlastně hotovo. Čistotu řešení ověříme tím, že si vyzkoušíme dump vybraných položek po odeslání formuláře:</p>\n<pre><code class=\"lang-php\">public function success(UI\\Form $form, $vals) {\n    dump($vals);\n}\n</code></pre>\n<p>Čistota spočívá v tom, že požadované hodnoty skutečně získáme. To není úplně samozřejmé, protože v Nette existuje bezpečnostní obranný mechanismus, který zabraňuje odeslání hodnot v select boxu, které na začátku neobsahoval. Pokud něco takového uděláme třeba javascriptem, zíkáme <code>NULL</code>. Aby se toto nedělo, musíme takto relativně složitě vyřešit továrničku pro formulář.</p>\n<h2 id=\"-pinav-e-en-\">Špinavé řešení <a href=\"#-pinav-e-en-\">#</a></h2><p>Špinavé řešení se od toho čisté o moc neliší. Myšlenka je pořád stejná, tentokrát však stojíme před jiným úkolem. Vezměme si příklad, kdy nám zase až tolik nezáleží na tom, jaké získáme v select boxu hodnoty a chceme ho používat spíše jako text input, kdy nabídneme uživateli nějaký vstup. Typický příklad je text input pro URL adresu API, kdy po zadání kontaktujeme nějaké API a nabídneme v selectu vrácené hodnoty tak, aby je uživatel nemusel psát. Netvrdím, že by to nešlo vyřešit čistě, ale špinavé řešení je v tomto případě pohodlnější, rychlejší a mohu na něm ukázat i něco jiného. Tentokrát si vytvoříme úplně obyčejný formulář, tak jako již mnohokrát. Není potřeba žádného fíglu. Opět si připravíme šablonu pro formulář obdobně jako v předchozím případě. A obdobně doplníme nějaký ten javascript. Zde bych klidně mohl formulář upravit javascriptově, ale mě se hodí zavolat si (po napsání URL adresy) handler, v něm vyřešit vše potřebné a invalidovat část formuláře.</p>\n<pre><code class=\"lang-javascript\">var timer = null;\n$(&#39;input[name=url]&#39;).live(&#39;keyup&#39;, function () {\n    if (timer) {\n        clearTimeout(timer);\n    }\n    timer = setTimeout(function () {\n        timer = null;\n        $.nette.ajax({\n            url: {link checkErp!},\n            type: &#39;POST&#39;,\n            data: {\n                &quot;erpForm-url&quot;: $(&#39;input[name=url]&#39;).val()\n            }\n        });\n    }, 250);\n});\n</code></pre>\n<p>Handler nemá smysl uvádět. Jednoduše v něm vykonám nějakou logiku, vrátím data a invaliduji šablonu. Pozor na to, že předchozí javascriptová ukázka je tentokrát ze separátní komponenty.</p>\n<p>Zbývá nám vyřešit pouze odeslání a zpracování formuláře. Jelikož jsem byl teď líný programátor a select v tomto případě beru spíše jako text input, nemohu získat hodnotu select boxu ve <code>$form-&gt;getValues()</code>, resp. v druhém parametru succeeded metody. Musím proto použít metodu <code>getHttpData</code>, která mi umožní získat jakákoliv data a zároveň mám jistotu, že jsou data ošetřena:</p>\n<pre><code class=\"lang-php\">public function erpFormSucceeded(UI\\Form $form, Nette\\Utils\\ArrayHash $values) {\n    try {\n        $this-&gt;erpSystems-&gt;create([\n            ErpSystems::COLUMN_URL =&gt; $values-&gt;url,\n            ErpSystems::COLUMN_DATABASE =&gt; $form-&gt;getHttpData(UI\\Form::DATA_LINE, &#39;database&#39;), // &lt;- náš select\n            ErpSystems::COLUMN_USER =&gt; $values-&gt;username,\n            ErpSystems::COLUMN_TOKEN =&gt; $values-&gt;password,\n        ]);\n        //...\n    } catch (\\PDOException $exc) {\n        //...\n    }\n    //...\n}\n</code></pre>\n<p>V tomto špinavém řešení je však zapotřebí myslet na to, že v selectu může přijít naprosto cokoliv. To by však nikoho nemělo převapit. Ostatně i při vytváření formuláře stačí vytvořit select box prázdný, protože žádná vstupní data ani neexistují.</p>\n"
});
