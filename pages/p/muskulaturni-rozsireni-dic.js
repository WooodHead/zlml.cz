// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1482501056000,
    "title": "Muskulaturní rozšíření DIC",
    "slug": "muskulaturni-rozsireni-dic"
  },
  "body": "<p>K čemu je DI rozšíření v Nette a jak se takové rozšíření píše <a href=\"http://zlml.cz/rozsireni-pro-dic\">už víme</a>. Teď se podíváme na způsob, jak pracovat s takovým rozšířením na úplně nové úrovni. Tento článek velké spoustě lidí změní způsob práce a aplikace budou najednou o level výš. Jak řekl jeden z účastníků školení: tak to je geniální... :)</p>\n<h2 id=\"jak-strukturovat-aplikaci-\">Jak strukturovat aplikaci? <a href=\"#jak-strukturovat-aplikaci-\">#</a></h2><p>O tom už jsem se párkrát rozepsal a ještě se také minimálně jednou rozepíšu. Proteď jen rychlý úvod. Za tu dobu co dělám s frameworky jsem došel k tomu, že nemám žádnou složku s názvem <code>app</code>. Například struktura <a href=\"https://github.com/adeira/connector\">tohoto projektu</a> vypadá (zjednodušeně) takto:</p>\n<pre><code class=\"hljs\">.\n├── bin\n│   └── console\n├── config\n│   ├── config.local.neon\n│   ├── config.local.neon.travis\n│   ├── config.neon\n│   ├── extensions.neon\n│   └── services.neon\n├── log\n├── src\n│   ├── Authentication\n│   ├── Common\n│   ├── Devices\n│   ├── Endpoints\n│   └── Routing\n├── temp\n├── tests (obsahuje &#39;src&#39; se stejnou strukturou)\n├── vendor\n└── www\n</code></pre><p>Na tom není vůbec nic převratného. Důležitý je však způsob jakým se pracuje se službami (services). Pokud se totiž podíváme na obsah souboru <code>services.neon</code>, tak zjistíme, že je téměř prázdný:</p>\n<pre><code class=\"hljs lang-neon\">services:\n    migrations.codeStyle: Adeira\\Connector\\Migrations\\CodeStyle\n    router: Adeira\\Connector\\Routing\\RouterFactory::createRouter\n\n    doctrineSession: Adeira\\Connector\\Common\\Infrastructure\\Application\\Service\\DoctrineSession\n    dummySession:\n        class: Adeira\\Connector\\Common\\Infrastructure\\Application\\Service\\DummySession\n        autowired: no\n</code></pre>\n<p>Přitom celý projekt má v tuto dobu zhruba 80 služeb, které je potřeba zaregistrovat. Kde je tedy ta magie? Asi je zřejmé kam mířím. O vše se starají rozšíření dependency injection kontejneru. Ty jsou zaregistrovány v <code>extensions.neon</code>:</p>\n<pre><code class=\"hljs lang-neon\">extensions:\n    - Arachne\\ContainerAdapter\\DI\\ContainerAdapterExtension # because of migrations\n    - Arachne\\EventDispatcher\\DI\\EventDispatcherExtension # because of migrations\n    authentication: Adeira\\Connector\\Authentication\\Infrastructure\\DI\\Nette\\Extension\n    devices: Adeira\\Connector\\Devices\\Infrastructure\\DI\\Nette\\Extension\n    doctrine.orm: Adeira\\Connector\\Doctrine\\ORM\\DI\\Extension(%debugMode%)\n    fakeSession: Kdyby\\FakeSession\\DI\\FakeSessionExtension\n    graphql: Adeira\\Connector\\GraphQL\\Bridge\\Nette\\DI\\Extension\n    migrations: Zenify\\DoctrineMigrations\\DI\\MigrationsExtension\n    symfony.console: Adeira\\Connector\\Symfony\\Console\\DI\\Extension\n</code></pre>\n<p>Jak je vidět, tak každý balíček ve složce <code>src</code> má vlastní rozšíření (můž mít klidně víc rozšíření, ale není to potřeba). Na následujících řádcích ukážu jak takové rozšíření napsat super jednoduše.</p>\n<h2 id=\"roz-en-bez-znalosti-nette-di\">Rozšíření bez znalosti Nette\\DI <a href=\"#roz-en-bez-znalosti-nette-di\">#</a></h2><p>Psaní rozšíření pro DIC v Nette může být (a je) poměrně složité. Trošku to chce vědět, jak Nette funguje uvnitř. To samozřejmě dává do rukou obrovský nástroj, ale současně to také klade obrovskou překážku. Přesně z tohoto důvodu vznikl balíček <a href=\"https://github.com/adeira/compiler-extension\">adeira/compiler-extension</a>, který jsem napsal pro lidi ve firmách, kteří se Nette teprve učí, chtějí psát aplikace tak jako já a na prozkoumávání Nette\\DI není čas. Záběr tohoto balíčku není jen zde. Sám jsem si ho moc oblíbil a dnes tak píšu rozšíření také (ne vždy, ale dost často).</p>\n<p>Myšlenka je taková, že NEON formát umí každý. Pokud ne, tak si stačí prohlédnout <a href=\"https://ne-on.org/\">tuto stránku</a> a je to všem jasné (používám velmi úspěšně na školeních a přednáškách). Zároveň je snadné naučit o čem je DI, proč se musí v Nette registrovat služby v konfiguračním souboru a jak funguje autowiring. To v zásadě stačí k tomu, aby člověk začal psát aplikace mnohem lépe než dříve. Jenže pokud chce někdo strukturovat aplikaci tak jak to dělám já, tak musí registrovat všechny služby do souboru <code>services.neon</code> a těch je desítky až stovky (ne-li tisíce). Navíc je to nesmysl - proč by si takový balíček nemohl nést všechno s sebou (včetně konfigurací)?</p>\n<p>Ale on může! Podívejte se, jak vypadá takové rozšíření <code>Authentication</code> balíčku:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-meta\">&lt;?php</span> <span class=\"hljs-keyword\">declare</span>(strict_types = <span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Adeira</span>\\<span class=\"hljs-title\">Connector</span>\\<span class=\"hljs-title\">Authentication</span>\\<span class=\"hljs-title\">Infrastructure</span>\\<span class=\"hljs-title\">DI</span>\\<span class=\"hljs-title\">Nette</span>;\n\n<span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Adeira</span>\\<span class=\"hljs-title\">Connector</span>\\<span class=\"hljs-title\">Doctrine</span>\\<span class=\"hljs-title\">ORM</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Extension</span> <span class=\"hljs-keyword\">extends</span> \\<span class=\"hljs-title\">Adeira</span>\\<span class=\"hljs-title\">CompilerExtension</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ORM</span>\\<span class=\"hljs-title\">DI</span>\\<span class=\"hljs-title\">IMappingFilesPathsProvider</span>\n</span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">provideConfig</span><span class=\"hljs-params\">()</span>: <span class=\"hljs-title\">string</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">__DIR__</span> . <span class=\"hljs-string\">'/config.neon'</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getMappingFilesPaths</span><span class=\"hljs-params\">()</span>: <span class=\"hljs-title\">array</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-keyword\">__DIR__</span> . <span class=\"hljs-string\">'/../../Persistence/Doctrine/Mapping'</span>];\n    }\n\n}\n</code></pre>\n<p>Důležitá je metoda <code>provideConfig</code>, která slouží pouze k tomu, aby rozšíření prozradilo, kde je jeho konfigurační soubor. A tato konfigurace může být <a href=\"https://raw.githubusercontent.com/adeira/connector/03be1b949a0eb0c2f75c90ba3da5fca2ef8b2979/src/Authentication/Infrastructure/DI/Nette/config.neon\">pěkně bohatá</a>. Takovou nutnou prerekvizitou k tomu aby vše fungovalo je nahrazení výchozího <code>ExtensionsExtension</code> za novou implementaci, který toto chování umoňuje:</p>\n<pre><code class=\"hljs lang-php\">$configurator = <span class=\"hljs-keyword\">new</span> Nette\\Configurator;\n$configurator-&gt;defaultExtensions[<span class=\"hljs-string\">'extensions'</span>] = \\Adeira\\ConfigurableExtensionsExtension::class;\n</code></pre>\n<p>Tuto jednu řádku je nutné umístit třeba do souboru <code>bootstrap.php</code> kde se vytváří DI kontejner. Od teď bude toto chování fungovat &quot;by default&quot; a vlastní DI rozšíření dokonce může dědit od <code>Nette\\DI\\CompilerExtension</code>. <strong>Není tedy potřeba dělat žádné úpravy ve stávajících rozšířeních.</strong> A to je vždy super! Pokud bude rozšíření dědit od <code>Adeira\\CompilerExtension</code>, budete mít k dispozici ještě pomocnou metodu <code>setMapping</code>, která se hodí pro mapování presenterů. Není to však nutná podmínka.</p>\n<p>To ale není všechno!</p>\n<h2 id=\"jak-se-chovaj-konfigurace-bal-k-\">Jak se chovají konfigurace balíčků <a href=\"#jak-se-chovaj-konfigurace-bal-k-\">#</a></h2><p>Asi nejzajímavější na návrhu dependency injection je to, že je možné jednoduše vyměňovat implementace bez zásahu do kódu. Jak se tímto pracuje balíček <a href=\"https://github.com/adeira/compiler-extension\">adeira/compiler-extension</a>? Představte si, že máte hlavní konfigurační soubor s tímto obsahem:</p>\n<pre><code class=\"hljs lang-neon\">parameters:\n    key1: value1\n    key2: value2\n\nservices:\n    - DefaultService\n    named: Tests\\Service\n\nextensions:\n    ext2: CustomExtension2\n\next2:\n    ext_key1: ext_value1\n    ext_key2: ext_value2\n\napplication:\n    mapping:\n        *: *\n</code></pre>\n<p>A teď přidáte nový balíček, který si nese vlastní konfigurační soubor a pomocí metody <code>provideConfig</code> jej dává k dispozici. Jeho obsah je takovýto:</p>\n<pre><code class=\"hljs lang-neon\">parameters:\n    key2: overridden\n    key3: value3\n\nservices:\n    - Tests\\TestService\n    named: Service2\n\next2:\n    ext_key2: overridden\n    ext_key3: ext_value3\n\nlatte:\n    macros:\n        - App\\Grid\\Latte\\Macros\n</code></pre>\n<p>Jaký je výsledek? V aplikaci budou k dispozici najednou tři parametry (obdobně pro <code>ext2</code> parametry):</p>\n<pre><code class=\"hljs lang-neon\">parameters:\n    key1: value1\n    key2: overridden\n    key3: value3\n</code></pre>\n<p>Podobně se to chová i u služeb:</p>\n<pre><code class=\"hljs lang-neon\">services:\n    - DefaultService\n    named: Service2 # přepsat lze pouze pojmenovanou službu\n    - Tests\\TestService\n</code></pre>\n<p>Navíc se zaregistruje Latte makro. Ačkoliv toto chování funguje dobře, doporučuji jej spíše nevyužívat k přepisování globální konfigurace. Mnohem vhodnější je využívat tyto konfigurace k <strong>přidávání</strong> funkčností z balíčků. Tedy registrace nových služeb, přidávání commandů do konzole, registrace nových typů v Doctrine a podobně. V takovém případě se bude rozšíření chovat naprosto očekávaně. Vyhnete se tak tomu, že dva balíčky nastavují jeden parametr a záleží tam na pořadí. Je to nástroj - užijte jej s rozumem.</p>\n<p>To ale pořád není všechno!</p>\n<h2 id=\"mal-pozl-tko-na-z-v-r\">Malé pozlátko na závěr <a href=\"#mal-pozl-tko-na-z-v-r\">#</a></h2><p>Tento balíček přidává ještě jednu funkci, kterou považuji také za velmi užitečnou. Jak jistě víte, tak rozšíření se dá zaregistrovat pomocí sekce <code>extensions</code> a pokud rozšíření zaregistrujete pod nějakým jménem, je možné jej konfigurovat. To ostatně bylo vidět před malou chvílí:</p>\n<pre><code class=\"hljs lang-neon\">extensions:\n    ext2: CustomExtension2\n\next2:\n    ext_key1: ext_value1\n    ext_key2: ext_value2\n</code></pre>\n<p>V tomto případě budou klíče <code>ext_key1</code> a <code>ext_key2</code> k dispozici v samotném rozšíření. To se potom používá k různým úpravám chování samotného balíčku. Co když však nepíšete vlastní PHP kód, ale chcete jen předat tyto parametry do nějaké služby, kterou ono rozšíření registruje? K tomu slouží zvláštní zápis pomocí <code>%%</code>. V tomto konkrétním případě řekněme, že <code>CustomExtension2</code> má vlastní konfigurační soubor s tímto obsahem:</p>\n<pre><code class=\"hljs\">services:\n    - Tests\\TestService(%%ext_key2%%)\n</code></pre><p>Jak je vidět, tak si může vzít hodnotu <code>ext_key2</code> rovnou z konfigurace. Důležité je si uvědomit, že zatímco <code>%aaa%</code> bere parametr <code>aaa</code> ze sekce <code>parameters</code>, tak <code>%%aaa%%</code> bere konfiguraci <strong>pouze</strong> ze sekce, pod kterou je rozšíření zaregistrované. Chová se to tedy úplně stejně jako <code>$this-&gt;getConfig()</code> uvnitř rozšíření... :)</p>\n<p>Dejte <a href=\"https://github.com/adeira/compiler-extension\">tomuto rozšíření</a> šanci (nebo hvězdičku). Z praxe mohu říci, že se s ním pracuje skutečně dobře a pokud narazíte na to, že potřebujete udělat něco složitého - není problém pokračovat v psaní DI rozšíření v PHP zároveň s tímto. Uvítám také nápady na zlepšení a různé postřehy. Přecijen chvíli mi trvalo, než jsem přišel na ten správný způsob jak to uchopit.</p>\n<pre><code class=\"hljs\">composer require adeira/compiler-extension\n</code></pre><p>Instalace je jednoduchá... :)</p>\n"
});
