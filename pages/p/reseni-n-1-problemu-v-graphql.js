// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1485965763000,
    "title": "Řešení N+1 problému v GraphQL",
    "slug": "reseni-n-1-problemu-v-graphql"
  },
  "body": "<p>Na 85. Poslední sobotě v Praze jsem měl workshop a přednášku o GraphQL. Na konci přednášky padl velmi dobrý dotaz ohledně toho, jestli náhodou netrpí GraphQL v určitých situacích N+1 problémem. Načež jsem odvětil, že to není problém GraphQL, ale že ano. Teď je tedy ten správný čas podívat se na tuto situaci konkrétně a pokusit se ji vyřešit. Skvělé je, že <a href=\"http://webonyx.github.io/graphql-php/\">knihovna, kterou používám</a> na sebe částečně převzala řešení tohoto nešvaru. Ale o tom až za chvíli...</p>\n<h2 id=\"n-1-probl-m\">N+1 problém <a href=\"#n-1-probl-m\">#</a></h2><p>S <a href=\"https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/\">N+1 problémem</a> se setkal každý, kdo naprogramoval alespoň blog s komentáři. Problém nastává pokud se z databáze netahají všechna potřebná data s předstihem. Například pokud u blogu vytáhneme pouze články a až později budeme iterovat články a tahat k nim komentáře, pak máme N+1 problém. Stane se totiž, že položíme na databázi stejný počet dotazů, jako máme článků.</p>\n<p>Řešit se to dá dvojím způsobem. Můžeme použít databázový <code>JOIN</code> a v jednom dotázu si vytáhnout vše potřebné (články a kometáře) s tím, že již víme co potřebujeme. A nebo použijeme <code>IN</code> klauzuli a druhým dotazem se doptáme na vše potřebné (zbývající komentáře). Tento přístup se pro GraphQL hodí více.</p>\n<p>Hezký příklad tohoto problému je vidět na tomto GraphQL dotazu:</p>\n<pre><code>{\n  query_1: allWeatherStations {\n    edges {\n      node {\n        ...RecordsFragment\n      }\n    }\n  }\n  query_2: allWeatherStations {\n    weatherStations {\n      ...RecordsFragment\n    }\n  }\n}\n\nfragment RecordsFragment on WeatherStation {\n  records {\n    id\n  }\n}\n</code></pre><p>Toto by se dalo nazvat M*N+M problémem... :) Kdybych totiž posílal jen první dotaz (dej mi meteostanice a ke každé stanici všechny záznamy), vznikl by dříve popisovaný problém. Jen jsou zde místo článků meteostanice a místo komentářů jednotlivé záznamy stanic. Jenže v GraphQL lze skutečně složit graf a tak se můžu ptát velmi složitě a zamotaně. Dokonce se můžu ptát pořád dokolečka:</p>\n<pre><code>{\n  articles { # get all articles\n    authors { # get all authors of the articles\n      theirArticles { # get all articles they wrote\n        authors { # get authors of those articles\n          theirArticles {\n            ...\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre><p>Neříkám, že to dává smysl, ale pokud je API dostatečně kompikované, tak se zde můžou objevit cyklické cesty.</p>\n<h2 id=\"-e-en-\">Řešení <a href=\"#-e-en-\">#</a></h2><p>Podívejme se, jak se tahají jednotlivé záznamy pro konkrétní meteostanici:</p>\n<pre><code class=\"lang-php\">$field-&gt;setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {\n    return $this-&gt;allWsRecords-&gt;execute($userId, $ws-&gt;id());\n});\n</code></pre>\n<p>Slovy řečeno: v callbacku přijde meteostanice a my se zeptáme nějaké modelové třídy na všechny záznamy podle ID meteostanice. To je přesně to místo, kde vzniká N+1 problém. V knihovně <a href=\"https://github.com/webonyx/graphql-php\">webonyx/graphql-php</a> je od verze <code>v0.9.0</code> k dispozici objekt <code>GraphQL\\Deferred</code>, který perfektně poslouží k optimalizaci:</p>\n<pre><code class=\"lang-php\">$field-&gt;setResolveFunction(function (WeatherStation $ws, $args, UserId $userId) {\n    $this-&gt;allWsRecords-&gt;buffer($ws-&gt;id());\n\n    return new \\GraphQL\\Deferred(function() use ($userId, $ws) {\n        return $this-&gt;allWsRecords-&gt;execute($userId, $ws-&gt;id());\n    });\n});\n</code></pre>\n<p>Vtip je v tom, že při řešení dotazu prochází knihovna <code>webonyx/graphql-php</code> celý graf a zjišťuje potřebné hodnoty. Ve chvíli kdy dojde k našemu uzlu/listu, tak si jen poznamenáme (buffer) jaké ID bylo práve vyžadováno a vrátíme onen <code>Deferred</code> objekt. Až celý proces dojde na samotný konec, tak se knihovna zeptá ještě na ty odložené objekty. V tu chvíli ale již víme jaké všechny ID jsou potřeba a můžeme je získat jedním dotazem a postupně vracet:</p>\n<pre><code class=\"lang-php\">if(empty($this-&gt;weatherStationIdsBuffer)) {\n    return $this-&gt;wsrr-&gt;ofWeatherStationId($weatherStationId);\n} else {\n    static $result = NULL; //memoization\n    if ($result === NULL) {\n        $result = $this-&gt;wsrr-&gt;ofAllWeatherStationIds($this-&gt;weatherStationIdsBuffer);\n    }\n    return $result[$weatherStationId-&gt;id()];\n}\n</code></pre>\n<p>Tedy pokud není nic v bufferu, prostě se na to jedno ID zeptáme do databáze. Zde není co optimalizovat. V opačném případě však pošleme dotaz s <code>IN</code> a zeptáme se na všechny ID, které jsou v bufferu. Ty budeme chvíli držet v lokální cache a postupně ven servírovat jednotlivé záznamy (bez dalších dotazů do databáze).</p>\n<p>Výsledek je následující (předtím):</p>\n<pre><code class=\"lang-sql\">SELECT t0.* FROM user_accounts t0 WHERE t0.id = ?\n\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\n\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id = ?\n</code></pre>\n<p>A potom:</p>\n<pre><code class=\"lang-sql\">SELECT t0.* FROM user_accounts t0 WHERE t0.id = ?\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations w0_ WHERE w0_.owner_uuid = ?\nSELECT w0_.* FROM weather_stations_records w0_ WHERE w0_.weather_station_id IN (\n    &#39;df40acdd-5222-4f89-a693-999f2d3f3eb6&#39;,\n    &#39;6f5fb680-f5e3-4d8c-b7e1-27205b848657&#39;,\n    &#39;14837156-c662-4e8c-b527-2227506c2bf7&#39;,\n    &#39;2965494d-d13f-4415-8535-b910ac29326a&#39;,\n    &#39;662c0434-9eca-4241-9462-ce85d279fd6b&#39;,\n    &#39;36eed5a8-08fd-48db-8153-67355d092201&#39;\n)\n</code></pre>\n<p>To je obrovské zlepšení. Zejména když si uvědomíte, že k optimalizaci N+1 dotazu nedochází pouze naivně v rámci jedné cesty v grafu, ale v rámci úplně celého grafu. Pokud chcete vidět konkrétní změnu v rámci projektu z workshopu, tak je vidět v commitu <a href=\"https://github.com/adeira/connector/commit/ed8b43257b778b6b2d4adb1b92baae18daf36905\">ed8b43</a>.</p>\n<p>Toliko má odpoveď... :)</p>\n"
});
