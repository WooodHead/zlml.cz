// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1447611844000,
    "title": "Od indexu až po presenter",
    "slug": "od-indexu-az-po-presenter"
  },
  "body": "<p>Když jsem se učil pracovat s Nette Frameworkem, musel jsem v začátcích hodně přivírat oči a říkat si &quot;prostě to tak je&quot;. Hodně věcí bylo zahaleno do tmy. Teď už to tak naštěstí není, ale stále se stává, že mi někdo napíše a děkuje za poodhalení a vysvětlení toho, jak to funguje na pozadí (za což zase děkuji já). Pokusím se tedy pokračovat a vrátím se na úplný začátek - do <code>index.php</code> a poodhalím, jak probíhá start takové běžné aplikace. A jako vždy - co nejjednodušeji.</p>\n<p>Zodpovím (nebo alespoň nastíním odpovědi na) následující otázky:</p>\n<ul>\n<li>proč redirect vyvolává AbortException</li>\n<li>jak napsat vlastní NanoPresenter</li>\n<li>proč má Nette dva request objekty</li>\n<li>kde se bere životní cyklus presenteru</li>\n</ul>\n<h2 id=\"start-aplikace\">Start aplikace <a href=\"#start-aplikace\">#</a></h2><p>Nedávno jsem dostal v práci na starost implementovat Nette do jednoho legacy projektu. Už jsem tu o tom <a href=\"navrhovy-vzor-legacy-code\">psal</a>. Byl to nesmírně vyčerpávající úkol, ale už mám hotovo a jsem ve fázi nekonečného refaktoringu. Jednou z prvních věcí, které bylo nutné vyřešit byl start aplikace z jednoho místa. Toto naštěstí řeší <a href=\"https://github.com/nette/web-project\">web-project</a> (nebo <a href=\"https://github.com/nette/sandbox\">sandbox</a> chcete-li) už v základu takto (<code>.htaccess</code>):</p>\n<pre><code class=\"hljs\">&lt;IfModule mod_rewrite.c&gt;\n    RewriteEngine On\n\n    RewriteCond %{REQUEST_FILENAME} !-f\n    RewriteCond %{REQUEST_FILENAME} !-d\n    RewriteRule !\\.(pdf|js|ico|gif|jpg|png|css|rar|zip|tar\\.gz|map)$ index.php [L]\n&lt;/IfModule&gt;\n</code></pre><p>Čímž se velmi rychle dostáváme k prvnímu bodu, kterým je <code>index.php</code>:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@var</span> \\Nette\\DI\\Container $container */</span>\n$container = <span class=\"hljs-keyword\">require</span> <span class=\"hljs-keyword\">__DIR__</span> . <span class=\"hljs-string\">'/../app/bootstrap.php'</span>;\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@var</span> \\Nette\\Application\\Application $application */</span>\n$application = $container-&gt;getByType(\\Nette\\Application\\Application::class);\n$application-&gt;run();\n</code></pre>\n<p>V tomto souboru vše začíná a také končí. Totiž zavolá se ještě minimálně <code>\\Tracy\\Debugger::shutdownHandler</code>, <code>\\Nette\\Http\\Session::clean</code> a <code>\\Nette\\Http\\Response::__destruct</code>, ale zůstaňme u toho, že zde vše začíná a také končí. O co v indexu vlastně jde? Hned přeskočím první řádku, ačkoliv se jedná o nezanedbatelnou část. Z bootrapu získáme hotovou instanci <a href=\"https://doc.nette.org/cs/2.3/dependency-injection\">DIC</a>, resp. přímého potomka. Následuje vytažení <a href=\"https://api.nette.org/2.3.7/Nette.Application.Application.html\">Application</a> a naškytnutí aplikace pomocí metody <code>run</code>. To je předpokládám všem jasné, proto jsem to vzal letem světem. Cílem tohoto článku je však popsání právě <code>run</code> metod.</p>\n<h2 id=\"run-run-\">Run, run! <a href=\"#run-run-\">#</a></h2><p>Metoda <code>\\Nette\\Application\\Application::run</code> vypadá přesně takto:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">$this</span>-&gt;onStartup(<span class=\"hljs-keyword\">$this</span>);\n        <span class=\"hljs-keyword\">$this</span>-&gt;processRequest(<span class=\"hljs-keyword\">$this</span>-&gt;createInitialRequest());\n        <span class=\"hljs-keyword\">$this</span>-&gt;onShutdown(<span class=\"hljs-keyword\">$this</span>);\n    } <span class=\"hljs-keyword\">catch</span> (\\<span class=\"hljs-keyword\">Exception</span> $e) {\n        <span class=\"hljs-keyword\">$this</span>-&gt;onError(<span class=\"hljs-keyword\">$this</span>, $e);\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">$this</span>-&gt;catchExceptions &amp;&amp; <span class=\"hljs-keyword\">$this</span>-&gt;errorPresenter) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-keyword\">$this</span>-&gt;processException($e);\n                <span class=\"hljs-keyword\">$this</span>-&gt;onShutdown(<span class=\"hljs-keyword\">$this</span>, $e);\n                <span class=\"hljs-keyword\">return</span>;\n            } <span class=\"hljs-keyword\">catch</span> (\\<span class=\"hljs-keyword\">Exception</span> $e) {\n                <span class=\"hljs-keyword\">$this</span>-&gt;onError(<span class=\"hljs-keyword\">$this</span>, $e);\n            }\n        }\n        <span class=\"hljs-keyword\">$this</span>-&gt;onShutdown(<span class=\"hljs-keyword\">$this</span>, $e);\n        <span class=\"hljs-keyword\">throw</span> $e;\n    }\n}\n</code></pre>\n<p>Pro přehlednost to ještě zjednoduším a vyhodím vše, co pro samotné spuštění aplikace není nezbytně nutné:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">$this</span>-&gt;processRequest(<span class=\"hljs-keyword\">$this</span>-&gt;createInitialRequest());\n    } <span class=\"hljs-keyword\">catch</span> (\\<span class=\"hljs-keyword\">Exception</span> $e) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">$this</span>-&gt;catchExceptions &amp;&amp; <span class=\"hljs-keyword\">$this</span>-&gt;errorPresenter) {\n            <span class=\"hljs-keyword\">$this</span>-&gt;processException($e);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">throw</span> $e;\n    }\n}\n</code></pre>\n<p>Moc toho opět nezbylo. Vlastně se zde dějí jen tři věci. Prvně <a href=\"https://api.nette.org/2.3.7/source-Application.Application.php.html#102-124\">createInitialRequest</a>. Tato metoda vrátí (jak už název napovídá) tzv. aplikační request. To je objekt, který pak putuje celou aplikací a nese si informaci o tom co vlastně uživatel chce. Vzpomínáte si na článek o <a href=\"dynamicke-routovani-url-adres\">dynamickém routování URL adres</a>? Tam jsem ukazoval, jak se HTTP request změní právě na aplikační a zpět. Celá sranda se tedy odehrává někde v RouterFactory (zatím to platí, do budoucna ale <a href=\"https://github.com/nette/routing/commit/e802a85e96f5814ddf1a16ea1517398eb560bab6\">nebude</a>). Samotný HTTP request se pak dostane do <code>Application</code> díky DI. Už v <code>createInitialRequest</code> je tedy jasné, jestli je možné požadavek přeložit, nebo 404. Pokud 404, tak konec, resp. <code>processException</code> pokud je to v configu zapnuté (což jinými slovy znamená forward na error presenter):</p>\n<pre><code class=\"hljs lang-neon\">application:\n    catchExceptions: yes\n</code></pre>\n<p>Pokud se však povede získat aplikační request, nastupuje funkce <code>processRequest</code>. Mrkněte na <a href=\"https://api.nette.org/2.3.7/source-Application.Application.php.html#127-150\">implementaci</a>. Opět se nejedná o nic složitého. Jde zde vlastně jen o jedinou věc. Získat presenter a zavolat nad ním <code>run</code>. Proč <code>run</code>? Presenter totiž není potomek <code>\\Nette\\Application\\UI\\Presenter</code> jak si pamatují skoro všichni, ale spíše objekt, který implementuje interface <code>\\Nette\\Application\\IPresenter</code> jehož jedinou metodou je právě <code>run</code> do které se jako jediný parametr předává již zmíněný aplikační request. Zároveň musí tato metoda vracet <code>\\Nette\\Application\\IResponse</code>.</p>\n<p>Z toho plyne, že pokud potřebujeme velmi jednoduchý presenter (který skoro nic neumí, ale je rychlý), stačí si implementovat <code>IPresenter</code> rozhraní a hotovo:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NanoPresenter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Nette</span>\\<span class=\"hljs-title\">Object</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Nette</span>\\<span class=\"hljs-title\">Application</span>\\<span class=\"hljs-title\">IPresenter</span>\n</span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(Nette\\Application\\Request $appRequest)</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Nette\\Application\\Responses\\TextResponse(<span class=\"hljs-string\">'It works!'</span>);\n    }\n\n}\n</code></pre>\n<p>V běžném presenteru se toho však děje samozřejmě mnohem více. Právě v metodě <code>run</code> se schovává celý dobře známý životní cyklus presenteru. Než se však dostanu k reálnému příkladu, začnu na tomto jednoduchém. <code>NanoPresenter</code> vrací pouze <code>TextResponse</code> s obyčejným textem. Tato odpověď je předána zpět do <code>processRequest</code> a následně je hned zavoláno <code>\\Nette\\Application\\IResponse::send</code> což v tomto konkrétním případě vyústí v obyčejné echo. Co se však děje v běžném presenteru?</p>\n<h2 id=\"vykreslen-ablony\">Vykreslení šablony <a href=\"#vykreslen-ablony\">#</a></h2><p>Presenter, který dědí od <code>\\Nette\\Application\\UI\\Presenter</code> dělá téměř to samé. Jediný rozdíl je v tom, že presenter vlastně vykreslitelná komponenta, takže si vezme šablonu a předá ji stejně jako v předchozím případě do <code>TextResponse</code>. Zde je oproti mému <code>NanoPresenter</code> příkladu malý implementační rozdíl, ale ve výsledku presenter tak jako tak <code>TextResponse</code> vrátí zpět <code>Application</code> objektu do <code>processRequest</code> metody. Dále se opět zavolá <code>\\Nette\\Application\\Responses\\TextResponse::send</code>, tentokrát však nedojde k obyčejnému echu, ale spustí se renderování předané šablony (<code>\\Nette\\Application\\UI\\ITemplate</code>). Většinou to tedy propadne na Latte, ale to samozřejmě není podmínkou.</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">send</span><span class=\"hljs-params\">(Nette\\Http\\IRequest $httpRequest, Nette\\Http\\IResponse $httpResponse)</span>\n</span>{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">$this</span>-&gt;source <span class=\"hljs-keyword\">instanceof</span> Nette\\Application\\UI\\ITemplate) {\n        <span class=\"hljs-keyword\">$this</span>-&gt;source-&gt;render();\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">echo</span> <span class=\"hljs-keyword\">$this</span>-&gt;source;\n    }\n}\n</code></pre>\n<p>Z předchozího textu by mělo být zřejmé, kudy požadavek putuje. Když si prohlédnete detailněji to co jsem zde popsal, mělo by být jasné, že se interně používá <code>\\Nette\\Application\\AbortException</code> a proto je nebezpečné v presenterech chytat bezmyšlenkovitě všechny výjimky. Nikdo pak nechce řešit &quot;proč to Nette zase nepřesměrovává&quot;.</p>\n<p>Tento text by měl překlenout tu temnou propast mezi <code>index.php</code> a akcí v presenteru. Příště už se snad vrhnu na něco zajímavějšího... :)</p>\n"
});
