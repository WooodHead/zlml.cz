// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "id": "3d718b54-4cf2-40dd-8d54-fe865a3655d1",
    "timestamp": 1419375234000,
    "title": "RESP protokol - přímý přístup k Redis databázi",
    "slug": "resp-protokol-primy-pristup-k-redis-databazi"
  },
  "body": "<p><img src=\"*RESP*\" alt=\"\">(<a href=\"http://redis.io/topics/protocol\">http://redis.io/topics/protocol</a>) (<strong>RE</strong>dis <strong>S</strong>erialization <strong>P</strong>rotocol) je něco, s čím se asi většina lidí nepotká. Důvod je prostý. Tento protokol je většinou zabalen hluboko v knihovně, která pracuje s Redis databází. Existují však situace, kdy se tento protokol hodí. Jednou ze situací je stav, kdy potřebujete předat, nebo naopak získat z Redisu nějaká data a všechno ostatní vyjma RESP komunikace je zbytečné zdržování (u mě třeba sypání dat z procesoru přímo do Redisu). Druhý případ nastane v okamžiku, kdy potřebujete zajistit komunikaci klient-server a potřebujete zvolit vhodný formát přenosu informací. Jedná se tedy o použití tohoto protokolu úplně mimo Redis. Důvodů může být celá řada, nejhlavnější by však byl asi ten, že se s RESP formátem dat dá snadno pracovat, protože používá prefixový zápis.</p>\n<h2 id=\"form-t-resp-protokolu\">Formát RESP protokolu <a href=\"#form-t-resp-protokolu\">#</a></h2><p>RESP používá celkem 5 způsobů jak zaobalit přenášenou informaci. Vždy však platí, že první byte je byte určující o jaký formát se jedná:</p>\n<ul>\n<li><code>+</code> jednoduchý string</li>\n<li><code>-</code> error</li>\n<li><code>:</code> integer</li>\n<li><code>$</code> bulk string (binary safe)</li>\n<li><code>*</code> array</li>\n</ul>\n<p>Následuje samotný obsah, nebo dodatečné informace, například o délce a vše je ukončeno pomocí CRLF (<code>\\r</code>). Postupně tedy přenášené informace moho vypadat například takto:</p>\n<ul>\n<li><code>+PONG\\r</code></li>\n<li><code>-Error 123\\r</code></li>\n<li><code>:54986\\r</code></li>\n<li><code>$4\\r\nPING\\r</code> (první část určuje délku bulk stringu, NULL je pak <code>$-1\\r</code>)</li>\n<li><code>*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r</code> (první je délka pole, následuje kombinace předchozích)</li>\n</ul>\n<p>To je celé, žádná věda v tom není. Je to skutečně jednoduchý protokol a to je super, protože se s ním dá snadno pracovat. Navíc lze poslat celý dlouhý text obsahující více příkazů v jednom spojení.</p>\n<h2 id=\"implementace-v-node-js\">Implementace v Node.js <a href=\"#implementace-v-node-js\">#</a></h2><p>V Node.js by teď měla být realizace velmi jednoduchá. Napíšeme si krátký TCP client, který se nám napojí na Redis databázi (většinou port 6379) a budeme posílat/přijímat data:</p>\n<pre><code class=\"lang-javascript\">var net = require(&#39;net&#39;);\n\nvar client = net.connect({port: 6379}, function() {\n    console.log(&#39;Connected to the Redis server.&#39;);\n\n    client.write(&#39;*1\\r\n$4\\r\nPING\\r\n&#39;);\n    client.write(&#39;*3\\r\n$3\\r\nSET\\r\n$3\\r\nkey\\r\n$5\\r\nxxxxx\\r\n&#39;);\n    client.write(&#39;*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r\n&#39;);\n    client.write(&#39;*5\\r\n$5\\r\nPFADD\\r\n$11\\r\nHyperLogLog\\r\n$3\\r\nxxx\\r\n$3\\r\nyyy\\r\n$3\\r\nzzz\\r\n&#39;);\n    client.write(&#39;*2\\r\n$7\\r\nPFCOUNT\\r\n$11\\r\nHyperLogLog\\r\n&#39;);\n\n    client.write(&#39;*1\\r\n$7\\r\nFLUSHDB\\r\n&#39;);\n});\n\nclient.on(&#39;data&#39;, function(data) {\n    console.log(data.toString());\n    client.end();\n});\n\nclient.on(&#39;end&#39;, function() {\n    console.log(&#39;Disconnected from the Redis server.&#39;);\n});\n</code></pre>\n<p><span style=\"color:green\">Ještě jednu poznámku, kterou jsem do původního článku nezahrnul. Proč jsou udesílaná data zabalena v RESP poli? Vychází to z toho, že podle dokumentace, by klient měl posílat na server pole bulk stringů. Nicméně dobře funkční a validní zápis je i bez pole (<code>client.write(&#39;GET key\\r\n&#39;);</code>) jen musí být opět ukončen pomocí CRLF.</span></p>\n<p>Odesíláme do Redis databáze celkem 6 příkazů. První je obyčejný <code>PING</code>, následuje <code>SET</code> a <code>GET</code> klíče, <code>PFADD</code> a <code>PFCOUNT</code> z HyperLogLog datového dypu a nakonec jen smazání databáze. Co bude výstupem?</p>\n<pre><code>+PONG\n+OK\n$5\nxxxxx\n:0\n:3\n+OK\n</code></pre><p>Jak je možné, že server vrátil 7 odpovědí? Je to prosté, upravíme si datový callback ať je zřejmé, co skutečně dostáváme za data:</p>\n<pre><code class=\"lang-javascript\">client.on(&#39;data&#39;, function(data) {\n    console.log(JSON.stringify(data.toString()));\n    client.end();\n});\n</code></pre>\n<p>Teď už bude výstup o něco jiný:</p>\n<pre><code>&quot;+PONG\\r\n+OK\\r\n$5\\r\nxxxxx\\r\n:0\\r\n:3\\r\n+OK\\r\n&quot;\n</code></pre><p>A vše již dává smysl. První odpověď je <code>PONG</code> (na <code>PING</code>), následuje reakce <code>OK</code> na nastavení klíče, odpověď ve formě bulk stringu, který má dvě části - délku a samotnou textovou odpověď (proto to odřádkování navíc), následuje odpověď z <code>PFADD</code> (0 nebo 1 podle situace) a také odpověď z <code>PFCOUNT</code> (mohutnost množiny v HyperLogLog). Poslední <code>OK</code> je reakce na <code>FLUSHDB</code>. Jak je vidět, tak i v odpovědi je prvním znakem formát dat dané odpovědi.</p>\n<p>Takto jsem to celkem zbytečně (ale pro přehlednost) rozepisoval. Celá komunikace směrem k serveru by se dala napsat do jednoho požadavku:</p>\n<pre><code>*1\\r\n$4\\r\nPING\\r\n*3\\r\n$3\\r\nSET\\r\n$3\\r\nkey\\r\n$5\\r\nxxxxx\\r\n*2\\r\n$3\\r\nGET\\r\n$3\\r\nkey\\r\n*5\\r\n$5\\r\nPFADD\\r\n$11\\r\nHyperLogLog\\r\n$3\\r\nxxx\\r\n$3\\r\nyyy\\r\n$3\\r\nzzz\\r\n*2\\r\n$7\\r\nPFCOUNT\\r\n$11\\r\nHyperLogLog\\r\n*1\\r\n$7\\r\nFLUSHDB\\r\n</code></pre><p>Odpověď by zůstala stejná.</p>\n"
});
