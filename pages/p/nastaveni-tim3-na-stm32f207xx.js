// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1413669750000,
    "title": "Nastavení TIM3 na STM32F207xx",
    "slug": "nastaveni-tim3-na-stm32f207xx"
  },
  "body": "<p>Tento článek už mám dlouhou dobu v hlavě, ale nikdy jsem se neodvážil jej sepsat. Má to svůj smysl. Jedná se o poměrně náročnou problematiku, kterou si myslím, že moc lidí nechápe. Rád bych tedy tímto popíchnul čtenáře o zpětnou vazbu a pokud by se ukázalo, že to smysl má, pokračoval bych někam dál do složitějších věcí, protože toto bude ve výsledku směšně jednoduché... (-:</p>\n<p><img src=\"https://zlmlcz-media.s3-eu-west-1.amazonaws.com/f34b6d82-9aaf-4089-afe6-81993d596885/stm32.png\" alt=\"\"></p>\n<p>K dispozici mám momentálně dva procesory, ale budu řešit konkrétně <code>STM32F207xx</code>. Ten druhý je ze <code>4xx</code> řady, ale díky novým Cube knihovnám není v programech žádný rozdíl. Alespoň ne v tom, co bu ukazovat dnes. <a href=\"http://www.st.com/web/catalog/mmc/FM141/SC1169/SS1575/LN9/PF245085\">STM32F207</a> je procesor založený na 32-bit ARM(R) Cortex(R)-M3 od STMicroelecronics. Jedná se o procesor s 120 MHz jádrem, 1024 kB flash pamětí na program a 128 kB SRAM. Celkově se jedná o poměrně výkonnou mršku na které se toho nechá upočítat poměrně hodně a hlavně dokáže ovládat velké množství rozmanitých periferií viz obrázek. Na obrázku je přesně ta samá eval deska s tím samým procesorem, na kterou právě teď koukám. Nejzajímavější bude teď však právě onen procesor, který je uprostřed desky a SMD diody, které nejsou téměř vůbec vidět. Ty jsou umístěny nad Wakeup tlačítkem téměř pod displejem.</p>\n<p>A teď konečně o čem budu psát. TIM3 je timer ze skupiny TIM2-5. Jedná se o timer naprosto běžný a obyčejný. Celkem jich je k dispozici 14 ve 4 skupinách podle společných vlastností. Podívat se na ně můžete do <a href=\"http://www.st.com/web/en/resource/technical/document/reference_manual/DM00031020.pdf\">referenční příručky</a>, ale pozor ať se vám z toho nezamotá hlava, je toho tam fak hodně... (-: Ukážeme jak tento timer nastavit tak aby bylo možné blikat diodou jednou za 1000 ms. Navíc k tomu nebudeme využívat výkonu procesoru, ale využijeme přerušení, takže nebudeme procesor vůbec ničím zdržovat. O zrovna čekání procesoru 1000 ms, než bude moci bliknout diodou by byl slušný zabiják výkonu.</p>\n<h2 id=\"nastaven-timx-a-diod\">Nastavení TIMx a diod <a href=\"#nastaven-timx-a-diod\">#</a></h2><p>Je to jednudché. V souboru <code>main.c</code> existuje klasická viod metoda s while smyčkou, která bude na začátku i na konci tohoto programu prázdná:</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">\"main.h\"</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span> </span>{\n    HAL_Init();\n    SystemClock_Config();\n    # ...\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) {\n    }\n}\n</code></pre>\n<p>Cílem je neudělat žádnou blbost a nechat procesor nejlépe bez toho aby něco musel počítat, což je díky přerušení možné a doporučované. HAL (Hardware abstraction layer) vrstu a systémové hodiny nastavíme co nejdříve. <code>HAL_Init();</code> je systémová funkce Cube knihoven, která provede inicializaci HW abstraktní vrstvy. Ve skutečnosti HAL_Init spouští celou řadu dalších initů. <code>SystemClock_Config();</code> je již uživatelská metoda, která je umístěna v každém demu v Cube Examples, takže ji sem nebudu přepisovat. Je téměř vždy stejná. Následovat by však měla inicializace diod. Dalo by se to udělat i složitě, ale s využitím BSP (Board support package) je inicializace triviální:</p>\n<pre><code class=\"hljs lang-cpp\">BSP_LED_Init(LED1);\n# LED2, LED3, LED4\n</code></pre>\n<p>Teď tedy máme nastartovanou desku, hodiny a připravené diody k použití. Nezbývá než se pustit do nastavování timeru:</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-comment\">/*##-1- Configure the TIM peripheral #######################################*/</span>\nTimHandle.Instance = TIMx;\nTimHandle.Init.Period = <span class=\"hljs-number\">10000</span>;\nTimHandle.Init.Prescaler = (<span class=\"hljs-keyword\">uint32_t</span>)(((SystemCoreClock / <span class=\"hljs-number\">2</span>) / <span class=\"hljs-number\">10000</span>) - <span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//10kHz</span>\n<span class=\"hljs-comment\">// T = 1/f = 1/10k = 0,0001 ; time = Period * T = 1s</span>\nTimHandle.Init.ClockDivision = <span class=\"hljs-number\">0</span>;\nTimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;\n<span class=\"hljs-keyword\">if</span>(HAL_TIM_OC_Init(&amp;TimHandle) != HAL_OK) {\n    Error_Handler();\n}\n</code></pre>\n<p><code>TIMx</code> je v <code>main.h</code> nastaven na TIM3, period je délka intervalu a prescaler je předdělička frekvence, která je díky tomu výpočtu nastavena nezávisle na rychlosti hodin na jednotnou frekvenci 10 kHz. Teď si stačí jen oprášit středoškolskou elektroniku. Pokud víme, že <code>T = 1/f</code> a frekvence je 10 000 Hz, pak je perioda takového průběhu 0,1 ms. To je docela průser, protože je to srašně rychlé. Proto je zde právě ta perioda timeru, kde v podstatě říkáme, že toto má proběhnout 10 000x a pak až cvrnknout timerem. A voilà, máme 1 vteřinu. <code>TIM_COUNTERMODE_UP</code> přávě říká, že bude počítat dokud nenarazí na strop a pak timer přeteče. Snad jedině pozor na jednu zradu. TIM3 má prescaler 16 bitový, tzn. lze nastavit maximálně hodnotu 2^16 -1 = 65535! Vzhledem k tomu, že to z výpočtu není přímo vidět, tak se na to můžete snadno nachytat a timer pak poběží jinak než bylo požadováno. Dále si nastavíme kanál, který budeme využívat k blikání diodou, protože teď timer pouze dojede na 10 000 a vyresetuje se:</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-comment\">/*##-2- Configure the Output Compare channels #########################################*/</span>\nsConfig.OCMode = TIM_OCMODE_TOGGLE;\nsConfig.Pulse = uhCCR1_Val;\nsConfig.OCPolarity = TIM_OCPOLARITY_LOW;\n<span class=\"hljs-keyword\">if</span>(HAL_TIM_OC_ConfigChannel(&amp;TimHandle, &amp;sConfig, TIM_CHANNEL_1) != HAL_OK) {\n    Error_Handler();\n}\nsConfig.Pulse = uhCCR2_Val;\n<span class=\"hljs-keyword\">if</span>(HAL_TIM_OC_ConfigChannel(&amp;TimHandle, &amp;sConfig, TIM_CHANNEL_2) != HAL_OK) {\n    Error_Handler();\n}\n</code></pre>\n<p>Před vstupem do main metody je zapotřebí nastavit si ještě pulse hodnoty:</p>\n<pre><code class=\"hljs lang-cpp\">__IO <span class=\"hljs-keyword\">uint32_t</span> uhCCR1_Val = <span class=\"hljs-number\">100</span>;\n__IO <span class=\"hljs-keyword\">uint32_t</span> uhCCR2_Val = <span class=\"hljs-number\">200</span>;\n</code></pre>\n<p>Abych to krátce vysvětlil. Tímto jsem si nastavil, že až timer dosáhne hodnoty 100 a 200, tak cvrnkne a to pokaždé do jiného kanálu. Při dosažení maxima (10 000) dojde k přetečení timeru a ten začne počítat znovu. Je jedno jak tyto hodnoty nastavím, ale musí být od sebe 100 ms. Chci totiž zapnout diodu a dned ji vypnout. Toto se bude opakovat každných 1000 ms viz předchozí nastavení timeru. Super, takže teď máme timer co počítá a v určitém okamžiku pošle dva signály. Tak to nahodíme a jedeme... (-:</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-comment\">/*##-3- Start signals generation #######################################*/</span>\n<span class=\"hljs-comment\">/* Start channel 1 in Output compare mode */</span>\n<span class=\"hljs-keyword\">if</span>(HAL_TIM_OC_Start_IT(&amp;TimHandle, TIM_CHANNEL_1) != HAL_OK) {\n    Error_Handler();\n}\n<span class=\"hljs-keyword\">if</span>(HAL_TIM_OC_Start_IT(&amp;TimHandle, TIM_CHANNEL_2) != HAL_OK) {\n    Error_Handler();\n}\n</code></pre>\n<p>Skvělé na tom je to, že teď už to fakt cvaká a stačí se na to jen pověsit přepínání stavu diod.</p>\n<h2 id=\"kone-n-blik-me-\">Konečně blikáme! <a href=\"#kone-n-blik-me-\">#</a></h2><p>K tomu, aby bylo možné blikat, musíme se chytit callbacku, který je v HAL připraven. Zde se podíváme, jestli je daný kanál aktivní a pokud ano, znamená to, že můžeme něco udělat. V tomto případě tedy nejdříve zapnu diodu a za 100 ms přijde signál druhým kanálem a já ji mohu opět vypnout. Za 1s se celý proces opakuje. Paráda!</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-comment\">/**\n  * @brief  Output Compare callback in non blocking mode \n  * @param  htim : TIM OC handle\n  * @retval None\n  */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">HAL_TIM_OC_DelayElapsedCallback</span><span class=\"hljs-params\">(TIM_HandleTypeDef *htim)</span> </span>{\n    <span class=\"hljs-keyword\">if</span>(htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_1) {\n        BSP_LED_On(LED1);\n      }\n    <span class=\"hljs-keyword\">if</span>(htim-&gt;Channel == HAL_TIM_ACTIVE_CHANNEL_2) {\n        BSP_LED_Off(LED1);\n      }\n}\n</code></pre>\n<p>Ještě bych měl zmínit metodu <code>Error_Handler();</code>, která se zde často opakuje. Je to metoda, která se zavolá, když se něco nepovede a její obsah může být opět prázdná smyčka, aby procesor nezačal dělat nějaké nesmysly:</p>\n<pre><code class=\"hljs lang-cpp\"><span class=\"hljs-comment\">/**\n  * @brief  This function is executed in case of error occurrence.\n  * @param  None\n  * @retval None\n  */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Error_Handler</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">void</span>)</span> </span>{\n    BSP_LED_On(LED4);\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>) {}\n}\n</code></pre>\n<p>Asi není úplně hloupé zapnout i nějakou (červenou) diodu, která bude signalizovat error. Rád bych zmínil to, že by bylo možné v main metodě v cyklu spustit <code>BSP_LED_Toggle(LED4);</code> a počkat 1 vteřinu. To by bylo funkční, ale jak by se ukázalo časem, tak by tento program mohl sloužit pouze pro blikání diodou, což není moc užitečné. Pokud bych se k tomu dostal, tak si můžeme ukázat jak pracovat s ethernetem a zde se ukáže, že je prázdný while potřeba. Tímto způsobem mi však nic nebrání blikat si diodou a vedle toho ještě tlačit data ethernetem pryč...</p>\n<p>Tak co, dalo se to vydržet? :-)</p>\n"
});
