// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1510619991384,
    "title": "Persist your GraphQL queries!",
    "slug": "persist-your-graphql-queries"
  },
  "body": "<p>GraphQL is very powerful and I really love it. But it&#39;s not really production ready by default. There is a lot of things you need to prepare and one of them is called persistent (or sometimes static) queries. Let&#39;s have a look at what is it all about and why should one care. In the following examples, I will use Relay Modern as a client framework.</p>\n<h2 id=\"motivation\">Motivation <a href=\"#motivation\">#</a></h2><p>You will very often hear that GraphQL is great because it reduces the amount of data transferred between client and server. This is indeed behavior you&#39;ll get by default. But I was always doubting this argument little bit. It because you will transfer fewer data from the server to client (compare to the REST approach) but you will send much MUCH more data from the client to the server just to get those data. And as we all know uploads are usually super slow compare to the downloads. Actually - engineers from New York Times revealed that the larges queries may have up to <strong>20 kB</strong> and that&#39;s quite a lot for one question (yes, just the query itself without response). And I can imagine even bigger queries...</p>\n<p>How is it even possible? Well, very easily. With Relay, you can compose a lot of components (GraphQL fragments respectively) which results in really large GraphQL query (even with all the optimizations). You are just describing that you really need all those fields and there is nothing you can do about such query (assuming you are already using fragments).</p>\n<p>One way how to solve this issue is to <strong>send prepared queries to the server</strong> and request them only by the identifier. Let&#39;s say you have this query:</p>\n<pre><code class=\"lang-graphql\">{\n  leftComparison: hero(episode: EMPIRE) {\n    ...comparisonFields\n  }\n  rightComparison: hero(episode: JEDI) {\n    ...comparisonFields\n  }\n}\n\nfragment comparisonFields on Character {\n  name\n  appearsIn\n  friends {\n    name\n  }\n}\n\n# + additional 20 kB\n</code></pre>\n<p>Instead of bundling this query into client code you can persist it to the server and alias it using equivalent ID:</p>\n<pre><code class=\"lang-json\">{\n  &quot;id&quot;: &quot;8b84b5eeceae334fedf369ac6dd0c60a&quot;\n}\n</code></pre>\n<p>As you can see the request is much smaller and because server already knows what query is behind this ID it can respond with the same subgraph and again - save transferred data.</p>\n<p>But this is not the only motivation. Again - practical example but this time from Twitter. They use persistent (static) queries but not only to lower amount of transferred data but also <strong>to make it more secure</strong>. Because you (your company) are the only entity allowed to call this API, you can easily persist these optimized queries and allow only know queries to be called. This is very nice benefit! No one will call very expensive query on your services. Only you can destroy your own servers this way! :)</p>\n<h2 id=\"how-to-implement-it-\">How to implement it? <a href=\"#how-to-implement-it-\">#</a></h2><p>Relay Modern contains compiler to prepare your queries on the client side. It compiles them to the <code>__generated__</code> folders next to your components. So you can take advantage of it. Quite a <a href=\"https://github.com/staylor/graphql-wordpress/blob/master/packages/relay-wordpress/tools/persistedQueries.js\">naive approach</a> would be to find these files (queries) and upload them to your server. In my case, I wrote custom Relay compiler (for other reasons) so I can extend its behavior.</p>\n<p>Part of the code generation is <code>RelayFileWriter</code>. This class has one hidden configuration option called <code>persistQuery</code>. You can pass there your custom function and persist your queries to the backend service (pseudo-code):</p>\n<pre><code class=\"lang-js\">const persistQuery = async (queryText: string): Promise&lt;string&gt; =&gt; {\n  const queryIdentifier = await this.databaseService.persistQuery(queryText);\n  return queryIdentifier;\n}\n</code></pre>\n<p>At this moment Relay will do a very clever thing. It will remove <code>text</code> property from the generated query and add your new <code>id</code> instead. So all you need to do now is to adjust fetch function for your queries (IDs respectively because you don&#39;t have queries anymore). This is <a href=\"https://github.com/staylor/graphql-wordpress/blob/master/packages/relay-wordpress/src/relay/fetcher.js\">great example</a> how to do it.</p>\n<p>This process can be easily done in your CI environment so you don&#39;t have to care about it too much. You just write code as usual and everything else is completely automatic. And you can love GraphQL again... :)</p>\n"
});
