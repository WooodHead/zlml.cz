// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1490538013000,
    "title": "React + Redux - Apollo =  FapFap",
    "slug": "react-redux-apollo-fapfap"
  },
  "body": "<p>Na konci minulého roku jsem začal něco jako virtuální seriál o React vs. PHP aplikaci. Včera jsem na Poslední sobotě byl upozorněn na to, že už asi nepokračuju. To není pravda - pouze jsem je přestal číslovat... :) Po <a href=\"2-graphql\">GraphQL</a>, vyřešení <a href=\"reseni-n-1-problemu-v-graphql\">N+1 problému</a>, <a href=\"hexagonalni-architektura\">architektuře serverové části</a> a <a href=\"jak-na-lokalni-css-pro-react\">omezení CSS kontextu</a> v React komponentách je čas podívat se podrobněji na komunikaci se serverem.</p>\n<p>Ve výsledku jsem hodně rád, že jsem to tak oddaloval, protože jsem to asi tak třikrát celé předělával a konečně mám radost z toho jak to vypadá. Veškeré kódy týkající se <a href=\"https://github.com/adeira/connector-frontend\">frontendu</a> i <a href=\"https://github.com/adeira/connector\">backendu</a> jsou jako vždy k dispozici online pod MIT.</p>\n<h2 id=\"klientsk-komponenty\">Klientské komponenty <a href=\"#klientsk-komponenty\">#</a></h2><p>Až do nedávné chvíle jsem na straně webového prohlížeče používal pro komunikaci se serverem knihovnu Apollo. Interně Apollo využívá Redux store a já začal hodně vážně zvažovat, že začnu Redux store využívat mnohem více. V tu chvíli už nedávalo moc velký smysl používat Apollo a přišlo mi zajímavější starat se o Redux store sám.</p>\n<p>Dříve jsem Apollo používal tak, že existovala vždy nějaká nadřazená komponenta, která se dotazovala serveru a předávala data jiné komponentě. Takže jsem měl komponenty, kterým se říká kontejnery (pouze tahají data) a předávají data pro vykreslení tzv. prezentačním komponentám (pouze vykreslují, ale netahají data).</p>\n<p>Myšlenka kontejnerů a prezentačních komponent pořád zůstává. Rozdíl je teď v tom, že místo toho, aby kontejner získával data prostřednictvím Apolla, tak je připojen k Redux úložišti a v okamžiku připojení komponenty do DOMu se spustí Redux akce pro načtení dat:</p>\n<pre><code class=\"lang-javascript\">export const AllCamerasContainer = class extends React.Component {\n\n  componentWillMount() {\n    this.props.dispatch(loadAllCameras());\n  }\n\n  render = () =&gt; { /* ... */ }\n\n};\n\nexport default connect()(AllCamerasContainer);\n</code></pre>\n<p>Funkce <code>this.props.dispatch</code> je k dispozici díky nadřazené komponentě, která se vytváří pripojením k Redux úložišti pomocí <code>connect()</code>.</p>\n<p>Redux funguje tak, že se pomocí funkce <code>dispatch</code> vyvolá nějaká akce/příkaz (zde načtení všech kamer), ta prolítne reducerama což jsou úplně obyčejné funkce, které umí měnit podobu stavu Redux úložiště a následně se tento nový stav uloží a komponenta se automaticky překreslí. Důležité je, že Redux si vlastně drží stav všech komponent u sebe v jednom velkém globálním úložišti a akce resp. reducery slouží pro alespoň trošku rozumné ovládání jeho obsahu. Zároveň Redux úložiště nemá z hlediska kódu <strong>nic společného s Reactem</strong>. Redux je ke komponentě nějak napojen, ale může fungovat úplně bez Reactu.</p>\n<p>Funkce <code>loadAllCameras</code> slouží pro vytvoření objektu reprezentující nějakou akci. Ta se potom spouští pomocí <code>dispatch</code>. Akce je obyčejný JS objekt, který si nese informaci o typu akce + nějaká další dodatečná data. Pokud však chci data teprve načíst, je nutné vytvářet místo objektu funkci, která tak učiní:</p>\n<pre><code class=\"lang-javascript\">// relies on Redux Thunk middleware\nexport const loadAllCameras = () =&gt; {\n  return dispatch =&gt; {\n\n    dispatch({ // spuštění akce (což je jen obyčejný objekt) uvnitř jiné akce\n      type: ALL_CAMERAS_LOADING,\n    });\n\n    fetch(allCamerasQuery).then(({data}) =&gt; { // funkce pro získání dat (kvůli tomu je nutný Thunk)\n\n      dispatch({ // opět jen obyčejná akce spuštěná uvnitř jiné akce\n        type: ALL_CAMERAS_LOAD_SUCCESS,\n        cameras: data.allCameras,\n      });\n\n    });\n  }\n};\n</code></pre>\n<p>Zde začíná být vidět důvod, proč jsem opustil Apollo. Díky tomu, že mám teď v ruce veškeré akce a reducery, tak mohu pohodlně spouštět a řetězit akce jak se mi zachce. Až Redux spustí tuto akci (resp. <a href=\"https://github.com/gaearon/redux-thunk\">Redux Thunk</a>), tak si jen najde ten správný reducer (podle typu <code>ALL_CAMERAS_LOADING</code> resp. <code>ALL_CAMERAS_LOAD_SUCCESS</code>), ten upraví obsah Redux úložiště a protože máme deklarativní React, tak se data automaticky překreslí.</p>\n<h2 id=\"server-fetcher\">Server Fetcher <a href=\"#server-fetcher\">#</a></h2><p>V předchozí akci bylo vidět, že se volá funkce <code>fetch</code>. To je úplně jednoduchá funkce, která pošle na server GraphQL dotaz a vrátí odpověď (resp. Promise). Vlastně dělá jen to, že pomocí <a href=\"https://github.com/matthew-andrews/isomorphic-fetch\">isomorphic-fetch</a> položí dotaz ve správném formátu:</p>\n<pre><code class=\"lang-javascript\">return fetch(config.apiAddress, {\n  method: &#39;POST&#39;,\n  body: JSON.stringify({\n    query: graphQuery, // přichází jako argument fetcheru\n    variables: variables, // dtto\n    operationName: operationName // dtto\n  }),\n  headers\n}).then(response =&gt; response.json())\n  .then(json =&gt; {\n    return json; // zde budou příchozí data z API\n  });\n</code></pre>\n<p>Poskládat potřebné hlavičky je otázkou několika málo sekund:</p>\n<pre><code class=\"lang-javascript\">let headers = {\n  Accept: &#39;*/*&#39;,\n  &#39;Content-Type&#39;: &#39;application/json&#39;\n};\nlet token = Authenticator.getToken(); // localStorage\nif (token !== null) {\n  headers.authorization = token;\n}\n</code></pre>\n<p>Asi by bylo možné vracet rovnou pole <code>data</code>, které GraphQL API vrací, aby nebylo nutné dělat destructing v akcích, ale to už jsou jen kosmetické detaily.</p>\n<p>Teď by tedy mělo být zřejmé následující:</p>\n<ul>\n<li>v Reactu existují kontejnery, což jsou komponenty, které <strong>tahají data</strong></li>\n<li>existují také prezentační komponenty, které <strong>jen vykreslují data</strong> podle <code>props</code></li>\n<li>kontejnery získávají data z Redux úložiště spuštěním akce při připojování kontejneru do DOMu (<code>componentWillMount</code>)</li>\n<li>součástí spuštění akce může být načtení těchto dat do úložiště (pokud tam již nejsou)</li>\n<li>na server se požadavky posílají jako jednoduchý POST s tělem obsahujícím GraphQL dotaz</li>\n<li>souběžně s tělem POST požadavku je nutné odeslat také autorizační hlavičky (pokud to aplikace vyžaduje)\nOK? Možná to bylo rychlé, ale <a href=\"https://github.com/adeira/connector-frontend\">mrkněte na kód</a> a popř. si to vyzkoušejte. Nic složitého... :)</li>\n</ul>\n<h2 id=\"p-ijet-po-adavku-na-php-serveru\">Přijetí požadavku na PHP serveru <a href=\"#p-ijet-po-adavku-na-php-serveru\">#</a></h2><p>Dostáváme se do oblasti, ve které <a href=\"https://forum.nette.org/cs/28370-data-z-post-request-body-reactjs-appka-se-po-ceste-do-php-ztrati\">se vypastí</a> překvapivě hodně lidí. Na straně serveru je třeba přistupovat k POST datům <a href=\"https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php#L62\">trošku jinak</a>, než by mohlo být zřejmé. K této trošce teorie bude potřeba následující PHP kód:</p>\n<pre><code class=\"lang-php\">&lt;?php\n\nvar_dump(\n  $_POST,\n  file_get_contents(&#39;php://input&#39;)\n);\n</code></pre>\n<p>Co se stane, pokud odešleme POST požadavek obsahující JSON třeba pomocí konzole v prohlížeči?</p>\n<pre><code class=\"lang-javascript\">var xhr = new XMLHttpRequest();\nxhr.open(&quot;POST&quot;, &quot;test.php&quot;, true);\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;);\nxhr.send(&quot;{a:&#39;b&#39;}&quot;);\n</code></pre>\n<p>Vrátí se tato odpoveď:</p>\n<pre><code>array(1) {\n  [&quot;{a:&#39;b&#39;}&quot;]=&gt;\n  string(0) &quot;&quot;\n}\nstring(7) &quot;{a:&#39;b&#39;}&quot;\n</code></pre><p>Obsah <code>$_POST</code> pole může být zvláštní, ale s tím by se dalo žít. Vzhledem k tomu, že se požadavek posílá jako formulář, tak se očekává trošku jiný formát dat:</p>\n<pre><code class=\"lang-javascript\">xhr.send(&quot;a=1&amp;b=2&quot;);\n</code></pre>\n<p>V tomto případě pole pěkně expanduje:</p>\n<pre><code>array(2) {\n  [&quot;a&quot;]=&gt;\n  string(1) &quot;1&quot;\n  [&quot;b&quot;]=&gt;\n  string(1) &quot;2&quot;\n}\nstring(7) &quot;a=1&amp;b=2&quot;\n</code></pre><p>Co se však stane, pokud změníme hlavičku požadavku <code>Content-Type</code>?</p>\n<pre><code class=\"lang-javascript\">var xhr = new XMLHttpRequest();\nxhr.open(&quot;POST&quot;, &quot;test.php&quot;, true);\nxhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json; charset=UTF-8&quot;);\nxhr.send(&quot;a=1&amp;b=2&quot;);\n</code></pre>\n<p>POST pole bude zcela prázdné! (nikoliv však <code>php://input</code>)</p>\n<pre><code>array(0) {\n}\nstring(7) &quot;a=1&amp;b=2&quot;\n</code></pre><p>Jak je totiž psáno v dokumentaci, tak <code>$_POST</code> neobsahuje všechna data, která jsou na server odeslána jako POST, nýbrž:</p>\n<blockquote>\n<p>An associative array of variables passed to the current script via the HTTP POST method <strong>when using application/x-www-form-urlencoded or multipart/form-data as the HTTP Content-Type</strong> in the request.</p>\n</blockquote>\n<p>Druhá polovina věty je extrémně důležitá. Také je z předchozích ukázek vidět, že jediné místo, kde jsou data k dispozici je právě input stream <code>php://input</code>. Z toho důvodu je na serveru k JSON datům nutné přistupovat rovnou přímo pomocí <code>file_get_contents(&#39;php://input&#39;)</code> (tak to dělá vnitřně <code>Nette/Http/RequestFactory</code>) nebo pomocí <code>$httpRequest-&gt;getRawBody()</code>, což je úplně to samé, jen více schované a více objektové.</p>\n<p>Nyní již stačí pouze ověřit uživatele, jestli se může API vůbec ptát, získat JSON, rozparsovat dotaz a poslat jej nějaké GraphQL knihovně ať se postará o všechny strasti tohoto API. Vše je vidět v tomto jednoduchém <a href=\"https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php\">GraphQL endpointu</a>.</p>\n<p>Kdyby někdo prahnul po pořádné náloži uceleného textu, tak je možné sledovat <a href=\"https://github.com/mrtnzlml/dp-latex/blob/master/main.pdf\">tento soubor</a> (stále rozdělaný), který jednou začas trošku povyroste. Nějaké základní znalosti problematicky jsou nutné, ale použitý jazyk by měl být srozumitelný většině lidí. Připomínky jsou vítány, než bude pozdě... :)</p>\n"
});
