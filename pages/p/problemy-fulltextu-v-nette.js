// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1375215333000,
    "title": "Problémy fulltextu v Nette",
    "slug": "problemy-fulltextu-v-nette"
  },
  "body": "<p>Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (<a href=\"http://zlml.cz/using-fulltext-searching-with-innodb\">http://zlml.cz/using-fulltext-searching-with-innodb</a>).\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\nbylo řešení <a href=\"http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php\">Jakuba Vrány .{target:_blank}</a>.</p>\n<p>V diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\nkterá jsou kratší než je hodnota <strong>ft_min_word_len</strong>. Implementace pro Nette nebude nijak zvlášť\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.</p>\n<h2 id=\"nette-ty-jedna-zr-dn-bestie-\">Nette, ty jedna zrádná bestie... <a href=\"#nette-ty-jedna-zr-dn-bestie-\">#</a></h2><p>Pro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\npoužití <strong>REGEXP</strong>.</p>\n<p>Běžný kód pro fultextové dotazování může vypadat takto:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@var</span> Nette\\Database\\SelectionFactory <span class=\"hljs-doctag\">@inject</span> */</span>\n<span class=\"hljs-keyword\">public</span> $sf;\n\n<span class=\"hljs-keyword\">$this</span>-&gt;sf-&gt;table(<span class=\"hljs-string\">'mirror_posts'</span>)\n    -&gt;where(<span class=\"hljs-string\">\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\"</span>, $search)\n    -&gt;order(<span class=\"hljs-string\">\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\"</span>, $search, $search)\n    -&gt;limit(<span class=\"hljs-number\">50</span>);\n</code></pre>\n<p>Což vygeneruje přibližně přesně následující:</p>\n<pre><code class=\"hljs lang-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-string\">`id`</span>, <span class=\"hljs-string\">`title`</span>, <span class=\"hljs-string\">`body`</span> \n<span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">`mirror_posts`</span> \n<span class=\"hljs-keyword\">WHERE</span> (<span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>, <span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span> <span class=\"hljs-keyword\">IN</span> <span class=\"hljs-built_in\">BOOLEAN</span> <span class=\"hljs-keyword\">MODE</span>)) \n<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) + <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) <span class=\"hljs-keyword\">DESC</span> \n<span class=\"hljs-keyword\">LIMIT</span> <span class=\"hljs-number\">50</span>\n</code></pre>\n<p>Bohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě <strong>ft_min_word_len</strong>, kterou mám nastavenou\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\nposkládám složitější dotaz:</p>\n<pre><code class=\"hljs lang-php\">$where = <span class=\"hljs-string\">\"\"</span>;\n<span class=\"hljs-comment\">//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE 'ft_min_word_len'\"), 0, 1);</span>\n$ft_min_word_len = <span class=\"hljs-number\">4</span>;\npreg_match_all(<span class=\"hljs-string\">\"~[\\\\pL\\\\pN_]+('[\\\\pL\\\\pN_]+)*~u\"</span>, stripslashes($search), $matches);\n<span class=\"hljs-keyword\">foreach</span> ($matches[<span class=\"hljs-number\">0</span>] <span class=\"hljs-keyword\">as</span> $part) {\n    <span class=\"hljs-keyword\">if</span> (iconv_strlen($part, <span class=\"hljs-string\">\"utf-8\"</span>) &lt; $ft_min_word_len) {\n        $regexp = <span class=\"hljs-string\">\"REGEXP '[[:&lt;:]]\"</span> . addslashes($part) . <span class=\"hljs-string\">\"[[:&gt;:]]'\"</span>;\n        $where .= <span class=\"hljs-string\">\" OR (title $regexp OR body $regexp)\"</span>;\n    }\n}\n</code></pre>\n<p>A doplníme fluidní dotaz:</p>\n<pre><code class=\"hljs lang-php\">...\n-&gt;where(<span class=\"hljs-string\">\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\"</span>, $search) <span class=\"hljs-comment\">//přidáno $where</span>\n...\n</code></pre>\n<p>Nyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:</p>\n<pre><code class=\"hljs lang-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-string\">`id`</span> \n<span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">`mirror_posts`</span> \n<span class=\"hljs-keyword\">WHERE</span> (<span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>, <span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span> <span class=\"hljs-keyword\">IN</span> <span class=\"hljs-built_in\">BOOLEAN</span> <span class=\"hljs-keyword\">MODE</span>) <span class=\"hljs-keyword\">OR</span> (<span class=\"hljs-string\">`title`</span> REGEXP <span class=\"hljs-string\">'[[:&lt;:]]`api`[[:&gt;:]]'</span> <span class=\"hljs-keyword\">OR</span> <span class=\"hljs-string\">`body`</span> REGEXP <span class=\"hljs-string\">'[[:&lt;:]]`api`[[:&gt;:]]'</span>)) \n<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) + <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) <span class=\"hljs-keyword\">DESC</span> \n<span class=\"hljs-keyword\">LIMIT</span> <span class=\"hljs-number\">50</span>\n</code></pre>\n<p>Bohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\nDůvodem jsou zpětné uvozovky v regulárním výrazu <strong>&#39;&#39;[[:&lt;:]]<code>api</code>[[:&gt;:]]&#39;&#39;</strong>.</p>\n<p>Řešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\npřímo ptá databáze. Existuje však vyčůranější způsob.</p>\n<p>Co jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:</p>\n<pre><code class=\"hljs lang-php\">$regexp = <span class=\"hljs-string\">\"REGEXP '[[:&lt;:]]\"</span> . addslashes(strtoupper($part)) . <span class=\"hljs-string\">\"[[:&gt;:]]'\"</span>;\n</code></pre>\n<p>A dotaz se následně poskládá strávně:</p>\n<pre><code class=\"hljs lang-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-string\">`id`</span>, <span class=\"hljs-string\">`title`</span>, <span class=\"hljs-string\">`body`</span> \n<span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">`mirror_posts`</span> \n<span class=\"hljs-keyword\">WHERE</span> (<span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>, <span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span> <span class=\"hljs-keyword\">IN</span> <span class=\"hljs-built_in\">BOOLEAN</span> <span class=\"hljs-keyword\">MODE</span>) <span class=\"hljs-keyword\">OR</span> (<span class=\"hljs-string\">`title`</span> REGEXP <span class=\"hljs-string\">'[[:&lt;:]]API[[:&gt;:]]'</span> <span class=\"hljs-keyword\">OR</span> <span class=\"hljs-string\">`body`</span> REGEXP <span class=\"hljs-string\">'[[:&lt;:]]API[[:&gt;:]]'</span>)) \n<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-number\">5</span> * <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`title`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) + <span class=\"hljs-keyword\">MATCH</span>(<span class=\"hljs-string\">`body`</span>) AGAINST (<span class=\"hljs-string\">'api'</span>) <span class=\"hljs-keyword\">DESC</span> \n<span class=\"hljs-keyword\">LIMIT</span> <span class=\"hljs-number\">50</span>\n</code></pre>\n<p>To že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\nvlastnost REGEXP, ale tabulkou s postfixem <strong>_ci</strong> se také nic nezkazí.</p>\n<p>Jen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\nale je to divné.</p>\n"
});
