// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1375215333000,
    "title": "Problémy fulltextu v Nette",
    "slug": "problemy-fulltextu-v-nette"
  },
  "body": "<p>Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (<a href=\"http://zlml.cz/using-fulltext-searching-with-innodb\">http://zlml.cz/using-fulltext-searching-with-innodb</a>).\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\nbylo řešení <a href=\"http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php\">Jakuba Vrány .{target:_blank}</a>.</p>\n<p>V diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\nkterá jsou kratší než je hodnota <strong>ft_min_word_len</strong>. Implementace pro Nette nebude nijak zvlášť\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.</p>\n<h2 id=\"nette-ty-jedna-zr-dn-bestie-\">Nette, ty jedna zrádná bestie... <a href=\"#nette-ty-jedna-zr-dn-bestie-\">#</a></h2><p>Pro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\npoužití <strong>REGEXP</strong>.</p>\n<p>Běžný kód pro fultextové dotazování může vypadat takto:</p>\n<pre><code class=\"lang-php\">/** @var Nette\\Database\\SelectionFactory @inject */\npublic $sf;\n\n$this-&gt;sf-&gt;table(&#39;mirror_posts&#39;)\n    -&gt;where(&quot;MATCH(title, body) AGAINST (? IN BOOLEAN MODE)&quot;, $search)\n    -&gt;order(&quot;5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC&quot;, $search, $search)\n    -&gt;limit(50);\n</code></pre>\n<p>Což vygeneruje přibližně přesně následující:</p>\n<pre><code class=\"lang-sql\">SELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST (&#39;api&#39; IN BOOLEAN MODE)) \nORDER BY 5 * MATCH(`title`) AGAINST (&#39;api&#39;) + MATCH(`body`) AGAINST (&#39;api&#39;) DESC \nLIMIT 50\n</code></pre>\n<p>Bohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě <strong>ft_min_word_len</strong>, kterou mám nastavenou\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\nposkládám složitější dotaz:</p>\n<pre><code class=\"lang-php\">$where = &quot;&quot;;\n//$ft_min_word_len = mysql_result(mysql_query(&quot;SHOW VARIABLES LIKE &#39;ft_min_word_len&#39;&quot;), 0, 1);\n$ft_min_word_len = 4;\npreg_match_all(&quot;~[\\\\pL\\\\pN_]+(&#39;[\\\\pL\\\\pN_]+)*~u&quot;, stripslashes($search), $matches);\nforeach ($matches[0] as $part) {\n    if (iconv_strlen($part, &quot;utf-8&quot;) &lt; $ft_min_word_len) {\n        $regexp = &quot;REGEXP &#39;[[:&lt;:]]&quot; . addslashes($part) . &quot;[[:&gt;:]]&#39;&quot;;\n        $where .= &quot; OR (title $regexp OR body $regexp)&quot;;\n    }\n}\n</code></pre>\n<p>A doplníme fluidní dotaz:</p>\n<pre><code class=\"lang-php\">...\n-&gt;where(&quot;MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where&quot;, $search) //přidáno $where\n...\n</code></pre>\n<p>Nyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:</p>\n<pre><code class=\"lang-sql\">SELECT `id` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST (&#39;api&#39; IN BOOLEAN MODE) OR (`title` REGEXP &#39;[[:&lt;:]]`api`[[:&gt;:]]&#39; OR `body` REGEXP &#39;[[:&lt;:]]`api`[[:&gt;:]]&#39;)) \nORDER BY 5 * MATCH(`title`) AGAINST (&#39;api&#39;) + MATCH(`body`) AGAINST (&#39;api&#39;) DESC \nLIMIT 50\n</code></pre>\n<p>Bohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\nDůvodem jsou zpětné uvozovky v regulárním výrazu <strong>&#39;&#39;[[:&lt;:]]<code>api</code>[[:&gt;:]]&#39;&#39;</strong>.</p>\n<p>Řešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\npřímo ptá databáze. Existuje však vyčůranější způsob.</p>\n<p>Co jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:</p>\n<pre><code class=\"lang-php\">$regexp = &quot;REGEXP &#39;[[:&lt;:]]&quot; . addslashes(strtoupper($part)) . &quot;[[:&gt;:]]&#39;&quot;;\n</code></pre>\n<p>A dotaz se následně poskládá strávně:</p>\n<pre><code class=\"lang-sql\">SELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST (&#39;api&#39; IN BOOLEAN MODE) OR (`title` REGEXP &#39;[[:&lt;:]]API[[:&gt;:]]&#39; OR `body` REGEXP &#39;[[:&lt;:]]API[[:&gt;:]]&#39;)) \nORDER BY 5 * MATCH(`title`) AGAINST (&#39;api&#39;) + MATCH(`body`) AGAINST (&#39;api&#39;) DESC \nLIMIT 50\n</code></pre>\n<p>To že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\nvlastnost REGEXP, ale tabulkou s postfixem <strong>_ci</strong> se také nic nezkazí.</p>\n<p>Jen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\nale je to divné.</p>\n"
});
