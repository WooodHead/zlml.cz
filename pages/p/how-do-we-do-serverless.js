// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1500731161000,
    "title": "How do we do serverless?",
    "slug": "how-do-we-do-serverless"
  },
  "body": "<p>In past few months, I moved completely from PHP backend to the JavaScript semi-frontend (not really backend but definitely not frontend - somewhere between). And I am glad I did it because finally, I can try every cool technology I always wanted but haven&#39;t had the opportunity. And one of these technologies is a serverless approach. It basically means that you still have servers but you are not taking care of the bare metal but you&#39;ll rather get computational power with all the fancy stuff like auto-scaling, high availability, related services orchestration and so on.</p>\n<p>Here at Kiwi.com (Prague), we are working on a lot of projects but one of them is more often pronounced - <a href=\"http://www.czechcrunch.cz/2017/05/brnenske-kiwi-com-otevira-v-praze-novou-pobocku-se-zamerenim-na-umelou-inteligenci/\">the chatbot</a>. This chatbot should help our customer support to manage tasks more easily. But the interesting part is that this application is <strong>completely serverless</strong>. This is how it works.</p>\n<h2 id=\"it-39-s-just-a-function\">It&#39;s just a function <a href=\"#it-39-s-just-a-function\">#</a></h2><p>The whole chatbot is just a function. Quite long and complicated one though. It&#39;s written in Node.js (ECMAScript 2017 - ES8 with a shit-ton of transpilers) and it runs on AWS Lambda. One of the best parts of the serverless is its deployment. We are using <a href=\"https://serverless.com/\">Serverless Framework</a> and that means that deployment to the serverless infrastructure is as easy as writing <code>serverless deploy</code>:</p>\n<pre><code>$ serverless deploy --stage staging\nServerless: Packaging service...\nServerless: Uploading CloudFormation file to S3...\nServerless: Uploading artifacts...\nServerless: Uploading service .zip file to S3...\nServerless: Validating template...\nServerless: Updating Stack...\nServerless: Checking Stack update progress...\n..........\nServerless: Stack update finished...\nService Information\nservice: chatbot\nstage: staging\nregion: eu-west-1\napi keys:\n  None\nendpoints:\n  POST - https://secret.eu-west-1.amazonaws.com/staging/\nfunctions:\n  chatbot: chatbot-staging-chatbot\nServerless: Removing old service versions...\n</code></pre><p>What does this framework do? Firstly it creates a ZIP file with the already transpiled and tested code. It also creates <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> template and uploads it to the AWS S3 storage. Now the magic happens. The new environment is created/updated thanks to the CloudFormation template. In our case, it means that it creates API Gateways, Lambda functions, and DynamoDB tables. This way you can invoke Lambda function just by calling URL address.</p>\n<p>The interesting part is that you can extend CloudFormation template however you want. In your case, we are just creating DynamoDB tables but I think you can do whatever you want (means whatever CloudFormation is able to do).</p>\n<h2 id=\"dazzle-me\">Dazzle me <a href=\"#dazzle-me\">#</a></h2><p>I&#39;ll show you just a simplified serverless definition (without the DynamoDB because it&#39;s too long), but the overall picture should be clear. The whole serverless infrastructure is defined in <code>serverless.yml</code>:</p>\n<pre><code class=\"lang-neon\">service: chatbot\n\nprovider:\n  name: aws\n  runtime: nodejs6.10\n  region: eu-west-1 # Ireland\n\nfunctions:\n  chatbot:\n    handler: dist/basicLambda.handler\n    events:\n      - http:\n          path: /\n          method: POST\n          cors: true\n          integration: lambda-proxy\n</code></pre>\n<p>It&#39;s quite self-explanatory. It&#39;s like a scenario: just create AWS Lambda function from <code>dist/basicLambda.js</code> file and on <code>POST</code> invoke a function in that file called <code>handler</code> (and yeah, also support CORS please). Since we are executing only transpiled and tested code it&#39;s a good idea to upload just that file:</p>\n<pre><code class=\"lang-neon\">package:\n  exclude:\n    - ./**\n  include:\n    - dist/*\n</code></pre>\n<p>DynamoDB and other services can be defined in the <code>resources</code> section. You just have to make sure that you&#39;ll setup IAM role permissions as well.</p>\n<p>And that&#39;s it. This is your &quot;ready for production&quot; environment. The last thing you have to do is just write the Lambda function for the chatbot. Easy...</p>\n<h2 id=\"chatbot-aws-lambda-function\">Chatbot AWS Lambda function <a href=\"#chatbot-aws-lambda-function\">#</a></h2><p>Since we are using so called <code>lambda-proxy</code> integration you have to take care of the inputs and outputs in your code on your own. But it&#39;s recommended and you should definitely do that.</p>\n<pre><code class=\"lang-javascript\">export async function handler(\n  event: Object,\n  context: ?Object,\n  callback: (error: null, success: Object) =&gt; void,\n) {\n  // error handling and so on...\n\n  callback(null, {\n    statusCode: 200,\n    headers: {\n      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;, // manual CORS (because of lambda-proxy)\n    },\n    body: JSON.stringify({\n      response: &quot;Sorry, I didn&#39;t understand your question. Say that again?&quot;,\n    }),\n  });\n}\n</code></pre>\n<p>Now, for me, this was always so confusing. It&#39;s because you hear - just run the function on AWS Lambda. But what does it mean? You have your shiny program full of classes and files and not only one function to run. Well, this is why you have Webpack right? You just inline everything into one file with all the mangling and uglifying and you are almost ready. The last thing is to expose your program via one handler and for AWS Lambda it should be in form of CommonJS (Webpack fragment):</p>\n<pre><code class=\"lang-javascript\">output: {\n  path: path.resolve(appDirectory, &#39;dist&#39;),\n  filename: &#39;[name].js&#39;,\n  libraryTarget: &quot;commonjs2&quot;,\n},\n</code></pre>\n<p>And that&#39;s it. This is how we do serverless (not only for chatbot). You should definitely try it if you are courageous enough.</p>\n"
});
