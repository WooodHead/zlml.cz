// @flow

import WithPost from '../../components/WithPost';

export default WithPost({
  "attributes": {
    "timestamp": 1469950790000,
    "title": "Dva šablonovací systémy zároveň",
    "slug": "dva-sablonovaci-systemy-zaroven"
  },
  "body": "<p>Možná pracujete na nějakém projektu, který používá jiný šablonovací systém než je Latte, ale Latte se vám natolik líbí, že ho chcete používat také. Nebo naopak používáte Latte, ale <em><abbr title=\"Smarty? Twig? Wtf? Omg?\">[doplň název šablonovacího systému]</abbr></em> se vám natolik líbí, že ho chcete používat také. A nebo prostě nemáte na výběr a musíte používat více šablonovacích systémů. V takovém případě existuje asi jediné přímočaré řešení a tím je vlastní implementace <code>Nette\\Application\\UI\\ITemplate</code>.</p>\n<h2 id=\"templatefactory\">TemplateFactory <a href=\"#templatefactory\">#</a></h2><p>Ono to vlastně zase až tak přímočaré není. Je v tom totiž malý háček. V současné době fungují Latte šablony tak, že existuje továrna <code>TemplateFactory</code>, jejíž úkolem je vytvářet <code>Template</code> objekty. Originální implementace, kterou používá většina lidí (<code>Nette\\Bridges\\ApplicationLatte\\Template</code>) pouze deleguje renderování přímo na Latte. Nabízelo by se tedy nahradit tento objekt svým vlastním a delegovat renderování jednak na Latte a jednak třeba na Smarty. Háček je však v tom, že <code>Template</code> není služba zaregistrovaná v DIC, takže není jednoduché ji nahradit.</p>\n<p>Proto aby bylo možné nahradit objekt <code>Template</code> vlastním, je nutné nahradit také <code>TemplateFactory</code>. Tento objekt vytváří nové instance třídy <code>Template</code> a tyto objekty dále nastavuje (přidává filtry, makra, proměnné, providery, prostě Nette specific věci). Nešvar s nahrazováním celé továrničky se už pár lidí <a href=\"https://github.com/nette/application/issues/141\">snažilo vyřešit</a>, ale nikdy to nikdo nedotáhl do konce (včetně mě). Jak to tedy udělat teď?</p>\n<p>V první řadě je třeba vytvořit si vlastní <code>TemplateFactory</code>:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-meta\">&lt;?php</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TemplateFactory</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Nette</span>\\<span class=\"hljs-title\">Application</span>\\<span class=\"hljs-title\">UI</span>\\<span class=\"hljs-title\">ITemplateFactory</span>\n</span>{\n    <span class=\"hljs-comment\">//...</span>\n}\n</code></pre>\n<p>To v podstatě znamená copy paste původní továrny. Je to trošku nepříjemné, ale je možné z toho těžit. Můžeme se například zbavit deprecated věcí, nebo si libovolně nakonfigurovat <code>Template</code> objekt. Podstatné je, že v <code>createTemplate</code> metodě vytváříme vlastní instanci <code>Template</code> objektu.</p>\n<p>Teď přijde ta důležitá část na kterou nesmíme zapomenout. Novou vlastní <code>TemplateFactory</code> zaregistrujeme do konfiguračního souboru jako službu:</p>\n<pre><code class=\"hljs lang-php\">services:\n    latte.templateFactory: Ant\\TemplateFactory\n</code></pre>\n<p>Tento zápis zajistí to, že se nejen <code>TemplateFactory</code> přidá do DI kontejneru, ale zároveň se nahradí původní implementace (proto to <code>latte.templateFactory</code> - důležité).</p>\n<h2 id=\"template\">Template <a href=\"#template\">#</a></h2><p>Samotný <code>Template</code> objekt už je pak prkotina. Stačí pouze změnit implementaci metody <code>render</code>. Já osobně jsem to řešil tak, že podle toho jaká přijde koncovka souboru, tak nabídnu ten správný engine pro vykreslení. Třeba nějak takto:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">render</span><span class=\"hljs-params\">($file = NULL, array $params = [])</span>\n</span>{\n    $file = $file ?: <span class=\"hljs-keyword\">$this</span>-&gt;getFile();\n\n    <span class=\"hljs-keyword\">if</span> (Strings::endsWith($file, <span class=\"hljs-string\">'.latte'</span>) || <span class=\"hljs-keyword\">$this</span>-&gt;getLatte()-&gt;getLoader() <span class=\"hljs-keyword\">instanceof</span> \\Latte\\Loaders\\StringLoader) {\n        <span class=\"hljs-comment\">//tady mám něco hustého co ukážu jindy</span>\n\n        <span class=\"hljs-keyword\">$this</span>-&gt;getLatte()-&gt;render($file, $params + <span class=\"hljs-keyword\">$this</span>-&gt;getParameters());\n       } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">//Smarty fallback</span>\n           <span class=\"hljs-comment\">//peklo které nechce nikdy vidět</span>\n\n        $providers = <span class=\"hljs-keyword\">$this</span>-&gt;getLatte()-&gt;getProviders();\n        <span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@var</span> \\Nette\\Application\\UI\\Presenter $presenter */</span>\n        $presenter = $providers[<span class=\"hljs-string\">'uiPresenter'</span>];\n        <span class=\"hljs-keyword\">if</span> ($presenter-&gt;isAjax()) {\n            <span class=\"hljs-keyword\">$this</span>-&gt;page-&gt;fetch($file);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">$this</span>-&gt;page-&gt;display($file);\n        }\n       }\n}\n</code></pre>\n<p>Trošku jsem to zjednodušil aby byla podtržena myšlenka. Doporučím však ještě jednu věc a to podědit si vlastní template od <code>Nette\\Bridges\\ApplicationLatte\\Template</code>. Chce to trošku si s tím pohrát, ale hlavní benefit bude vidět za chvíli. Zejména je dobré zaměřit se na <code>__set</code>:</p>\n<pre><code class=\"hljs lang-php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__set</span><span class=\"hljs-params\">($name, $value)</span>\n</span>{\n    <span class=\"hljs-keyword\">$this</span>-&gt;assignToSmarty($name, $value); <span class=\"hljs-comment\">//DIY</span>\n    <span class=\"hljs-keyword\">parent</span>::__set($name, $value);\n}\n</code></pre>\n<p>Teď je totiž možné používat klasické <code>$this-&gt;template-&gt;variable = &#39;xyz&#39;;</code> a tato proměnná bude k dispozici bez ohledu na způsob vykreslení.</p>\n<h2 id=\"gotchas-a-benefity\">Gotchas a benefity <a href=\"#gotchas-a-benefity\">#</a></h2><p>Každý teď tedy může používat například v komponentách <code>$this-&gt;template-&gt;render(&#39;***.tpl&#39;);</code> a zároveň mít třeba layout v Latte. Je to fuk. A to je cool. Je však třeba mít neustále na mysli, že nelze jednotlivé vykreslovací způsoby používat úplně nahodile. Styčiný bod je render metoda. Nelze tedy například používat include v Latte a vyžadovat tam šablonu ze Smarty.</p>\n<p>Asi největší nachytávka jsou snippety. Na to jak udělat podporu snippetů do Smarty se můžeme podívat jindy - není to nic složitého. Problém byl však u kombinování jednotlivých způsobů vykreslení a předávání <code>snippetMode</code> příznaku. <code>snippetMode</code> vlastně říká, jestli se má šablona vykreslit jako snippet (tedy jen podčásti) a vrátit v payloadu. Když jsem však použil komponentu ve Smarty (vlastní <code>{control name=test}</code>) a v této komponentě normální Latte šablonu obsahující snippety, tak to prostě nemohlo fungovat. Asi nejjednoušší řešení bylo v tomto případě trošku ohnout <code>Template</code> a <code>snippetMode</code> prostě přes tu aplikaci protlačit:</p>\n<pre><code class=\"hljs lang-php\">$presenter = <span class=\"hljs-keyword\">$this</span>-&gt;getLatte()-&gt;getProviders()[<span class=\"hljs-string\">'uiPresenter'</span>];\n<span class=\"hljs-keyword\">if</span> ($presenter-&gt;isAjax()) {\n    <span class=\"hljs-comment\">//propagate snippet mode into components (Smarty templates):</span>\n    <span class=\"hljs-keyword\">foreach</span> ($presenter-&gt;getComponents(<span class=\"hljs-keyword\">TRUE</span>) <span class=\"hljs-keyword\">as</span> $component) {\n        $component-&gt;snippetMode = $presenter-&gt;snippetMode;\n    }\n    <span class=\"hljs-keyword\">$this</span>-&gt;page-&gt;fetch($file);\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">$this</span>-&gt;page-&gt;display($file);\n}\n</code></pre>\n<p>Není to úplně stejné jako se chová Nette k Latte, ale účel to plní dobře a to jde... :)</p>\n"
});
