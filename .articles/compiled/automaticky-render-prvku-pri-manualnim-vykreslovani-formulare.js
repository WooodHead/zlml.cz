export default {
  "attributes": {
    "id": "103fd545-2922-4c42-b50c-6387a1f05d48",
    "timestamp": 1475925989000,
    "title": "Automatický render prvků při manuálním vykreslování formuláře",
    "slug": "automaticky-render-prvku-pri-manualnim-vykreslovani-formulare"
  },
  "body": "Je čas na nějakou tu Nette divočinu. Podívejme se pod drobnohledem na to, jak funguje vykreslování prvků formuláře. Nejprve si vytvoříme úplně jednoduchý formulář, který bude obsahovat jeden prvek:\n\n```php\nprotected function createComponentContactForm()\n{\n\t$form = new UI\\Form();\n\t$form->addSubmit('send', 'Odeslat');\n\t$form->onSuccess[] = function (UI\\Form $form, $values) {\n\t\tthrow new \\Nette\\NotImplementedException;\n\t};\n\treturn $form;\n}\n```\n\nJak bude vypadat takový formulář když jej vykreslíme pomocí `{control contactForm}`? Ve výchozím projektu asi nějak takto:\n\n```html\n<form action=\"/web-project/www/\" method=\"post\" id=\"frm-contactForm\">\n<table><tbody><tr>\n\t<th></th>\n\t<td><input type=\"submit\" name=\"send\" value=\"Odeslat\" class=\"button\"></td>\n</tr></tbody></table>\n<input type=\"hidden\" name=\"_do\" value=\"contactForm-submit\">\n</form>\n```\n\nAniž se budeme nořit do detailů, tak je zřejmé, že se kromě našeho odesílacího inputu vyrenderoval i nějaký hidden input automaticky. Než se posuneme dále z tohoto úvodu, zjistíme ještě, co se stane při manuálním vykreslování:\n\n```latte\n{form contactForm}\n\t{input send}\n{/form}\n```\n\nAčkoliv to není nikde dané, i v tomto případě se vykreslil další input prvek automaticky:\n\n```html\n<form action=\"/web-project/www/\" method=\"post\" id=\"frm-contactForm\">\n\t<input type=\"submit\" name=\"send\" value=\"Odeslat\">\n\t<input type=\"hidden\" name=\"_do\" value=\"contactForm-submit\">\n</form>\n```\n\n# Chytrý antispam prvek\n\nPo krátkém úvodu (který je zcela jistě každému jasný) se přesuneme k něčemu zdánlivě jinému. Vytvoříme si chytrý antispam prvek a zjistíme, jak se bude při renderování chovat a jestli se vždy chová předvídatelně. A asi nebude překvapením, že se v určité situaci zachová moc moc špatně. Jedná se o delší kód, takže jej [najdete na Gistu](https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a). Prakticky nejde o nic jiného, než že si vytvoříme vlastní antispam prvek. Tento prvek funguje tak, že vytvoří input ve kterém je nějaký text a pokud je k dispozici javascript, tak jej schová a smaže obsah. V tom případě je kontrola v pořádku, protože tiše předpokládá, že útočníkův robot nebude umět JS. Ačkoliv se to v dnešní době může zdát jako absurdní, tak to pořád funguje velmi dobře. Navíc přidává ještě pár honeypotů a doufá, že někde robot uvízne. Důležité je, že nijak neobtěžuje běžného návštěvníka - prostě to není vůbec vidět.\n\nNapíšeme si jednoduché rozšíření pro DI kontejner, aby bylo možné tento nový prvek používat:\n\n```php\n<?php\n\nnamespace App;\n\nuse Nette\\Forms\\Form;\n\nclass HoneypotExtension extends \\Nette\\DI\\CompilerExtension\n{\n\n\tpublic function afterCompile(\\Nette\\PhpGenerator\\ClassType $class)\n\t{\n\t\t$init = $class->methods['initialize'];\n\t\t$init->addBody(self::class . '::registerControlExtensionMethods();');\n\t}\n\n\tpublic static function registerControlExtensionMethods()\n\t{\n\t\tForm::extensionMethod('addAntispam', function (Form $form, $name = 'honeypot', $label = 'Vymažte toto pole') {\n\t\t\t$form[$name . '_1'] = new \\App\\Forms\\AntispamControl($name, $label);\n\t\t\treturn $form;\n\t\t});\n\t}\n\n}\n```\n\nToto rozšíření samozřejmě zaregistrujeme v konfiguračním souboru:\n\n```neon\nextensions:\n\t- App\\HoneypotExtension\n```\n\nA je to - v našem původním formuláři můžeme použít nový prvek:\n\n```php\n$form = new UI\\Form();\n$form->addAntispam();\n//...\n```\n\nJe to trošku magie a IDE si s tím neporadí. Proto nebude našeptávat. V tomto případě doporučuji napsat si nějakou vlastní `FormFactory`, která bude vytváře instance `UI\\Form` a do této třídy doplnit anotaci `@method addAntispam()`. Udělat si vlastní továrničku na `UI\\Form` není vůbec špatný nápad a to nejen pro antispam. Just do it.\n\nTak a teď když máme funkční antispam a honeypoty formuláře, je čas kouknout se co se děje při renderování. Nejdříve automatické - pomocí `{control contactForm}`. Zde není co řešit. Prostě se všechny potřebná políčka vyrenderují a vše je tak, jak by mělo být. A co manuální vykreslování? Zde začíná ta nepříjemná část. Nette nemůže vědět, že by měl automaticky vykreslit i další prvky, takže je prostě nevykreslí. Praktická zkušenost je taková, že při manuálním vykreslování prostě antispam přestane fungovat. Zde se musíme ještě zasnažit.\n\n# Chytřejší antispam prvek\n\nTeď musíme jít fakt na dřeň problému. Jak vlastně funguje to automatické renderování inputu při manuálním vykreslování? Existuje něco jako třída `Nette\\Bridges\\FormsLatte\\Runtime`, která má dvě metody: `renderFormBegin` a `renderFormEnd`. Právě druhá zmíněná přidává nějaký vlastní kód a je jedno, jestli se jedná o manuální, nebo automatické renderování formuláře. To by se nám hodilo. Vytvořme si tedy vlastní `Runtime` třídu. Není potřeba aby tato třída dědila od původní. Stačí, když si vykopírujeme metodu `renderFormEnd` a lehounce pozměníme prostřední foreach:\n\n```php\nforeach ($form->getControls() as $control) {\n\tif ($control->getOption('autorender') || ($control->getOption('type') === 'hidden' && !$control->getOption('rendered'))) {\n\t\t$s .= $control->getControl();\n\t}\n}\n```\n\nPřesně tak. Všechny čáry a kouzla se aktivují, když nastavíme prvkům `autorender` ([viz Gist](https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a)). Jenže kde se tato třída původně používala? Kde ji použijeme nyní?\n\nŘešení najdeme opět v namespace `Nette\\Bridges\\FormsLatte`, tentokrát však ve třídě `FormMacros`, která registruje formulářová makra. Vytvoříme si tedy vlastní implementaci `FormMacros` třídy, která bude dědit od původní:\n\n```php\nclass FormMacros extends \\Nette\\Bridges\\FormsLatte\\FormMacros\n{\n\n\tpublic static function install(\\Latte\\Compiler $compiler)\n\t{\n\t\t$me = new static($compiler);\n\t\t$me->addMacro('form', [$me, 'macroForm'], 'echo \\App\\Forms\\Runtime::renderFormEnd(array_pop($this->global->formsStack));');\n\t\t$me->addMacro('formContainer', [$me, 'macroFormContainer'], 'array_pop($this->global->formsStack); $formContainer = $_form = end($this->global->formsStack)');\n\t\t$me->addMacro('label', [$me, 'macroLabel'], [$me, 'macroLabelEnd'], NULL, self::AUTO_EMPTY);\n\t\t$me->addMacro('input', [$me, 'macroInput']);\n\t\t$me->addMacro('name', [$me, 'macroName'], [$me, 'macroNameEnd'], [$me, 'macroNameAttr']);\n\t\t$me->addMacro('inputError', [$me, 'macroInputError']);\n\t}\n\n}\n```\n\nDůležitá je zde registrace makra `{form}`, protože to pro svojí uzavírací značku používá novou implementaci `Runtime` (tu která podporuje autorender). Zaregistrujeme:\n\n```neon\nlatte:\n\tmacros:\n\t\t- App\\Forms\\FormMacros::install\n```\n\nSmažeme cache a profitujeme. Nyní se autospam vykresluje automaticky i při manuálním renderování... :)\n\nPodobně lze samozřejmě přidat i další kontroly jako je například kontrolní součet dvou čísel, který se javascriptem předvypočte automaticky, ale s vypnutým javascriptem se zobrazí políčka pro uživatele. Řešení tohoto antispamu je také [na mém Gistu](https://gist.github.com/mrtnzlml/961c3e2368e98aaa433e02c6603a5086). Jen je potřeba trošku rozšířit `HoneypotExtension`:\n\n```php\npublic static function registerControlExtensionMethods()\n{\n\tForm::extensionMethod('addAntispam', function (Form $form, $name = 'honeypot', $label = 'Vymažte toto pole') {\n\t\t$form[$name . '_1'] = new \\App\\AntispamControl($name, $label);\n\n\t\t$first = round(rand(0, 900), -2);\n\t\t$second = rand(0, 99);\n\t\t$validationData = self::encodeNumber($first) . ';' . self::encodeNumber($second);\n\t\t$form->addHidden('validationData', $validationData)->setOmitted(TRUE)->setOption('autorender', TRUE);\n\t\t$form[$name . '_3'] = new \\App\\Forms\\SumAntispamControl($first, $second, $validationData);\n\n\t\treturn $form;\n\t});\n}\n\nprivate static function encodeNumber($originalNumber)\n{\n\treturn strtr($originalNumber, '0123456789', '(_.!)@-*+&'); //cannot contain ';' character\n}\n```\n\nPůvodní kód zůstává stejný, jen jsem přidal další kontrolu a zakódoval číslice tak, aby nebylo jednoduché na první pohled poznat princip tohoto antispamu. Ve fantazii se meze nekladou.\n\nA právě v tom je možná trošku problém. Zejména kvůli autorender funkci je potřeba zasahovat do vnitřností Nette a zde je již na pováženou, jestli je to dobře či nikoliv. Velké úskalí vidím v tom, že si programátor vyměňuje stavební kameny Nette za svoje trošku upravené a to nemusí být vždy hned evidentní. Pak je na zamyšlenou, jestli by nestálo za to vytvořit PR. Kdo by ale stál o takovou hovadinu... :)"
}
