export default {
  "attributes": {
    "id": "103fd545-2922-4c42-b50c-6387a1f05d48",
    "timestamp": 1475925989000,
    "title": "Automatický render prvků při manuálním vykreslování formuláře",
    "slug": "automaticky-render-prvku-pri-manualnim-vykreslovani-formulare"
  },
  "body": "<p>Je čas na nějakou tu Nette divočinu. Podívejme se pod drobnohledem na to, jak funguje vykreslování prvků formuláře. Nejprve si vytvoříme úplně jednoduchý formulář, který bude obsahovat jeden prvek:</p>\n<pre><code class=\"lang-php\">protected function createComponentContactForm()\n{\n    $form = new UI\\Form();\n    $form-&gt;addSubmit(&#39;send&#39;, &#39;Odeslat&#39;);\n    $form-&gt;onSuccess[] = function (UI\\Form $form, $values) {\n        throw new \\Nette\\NotImplementedException;\n    };\n    return $form;\n}\n</code></pre>\n<p>Jak bude vypadat takový formulář když jej vykreslíme pomocí <code>{control contactForm}</code>? Ve výchozím projektu asi nějak takto:</p>\n<pre><code class=\"lang-html\">&lt;form action=&quot;/web-project/www/&quot; method=&quot;post&quot; id=&quot;frm-contactForm&quot;&gt;\n&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;\n    &lt;th&gt;&lt;/th&gt;\n    &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;send&quot; value=&quot;Odeslat&quot; class=&quot;button&quot;&gt;&lt;/td&gt;\n&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;\n&lt;input type=&quot;hidden&quot; name=&quot;_do&quot; value=&quot;contactForm-submit&quot;&gt;\n&lt;/form&gt;\n</code></pre>\n<p>Aniž se budeme nořit do detailů, tak je zřejmé, že se kromě našeho odesílacího inputu vyrenderoval i nějaký hidden input automaticky. Než se posuneme dále z tohoto úvodu, zjistíme ještě, co se stane při manuálním vykreslování:</p>\n<pre><code class=\"lang-latte\">{form contactForm}\n    {input send}\n{/form}\n</code></pre>\n<p>Ačkoliv to není nikde dané, i v tomto případě se vykreslil další input prvek automaticky:</p>\n<pre><code class=\"lang-html\">&lt;form action=&quot;/web-project/www/&quot; method=&quot;post&quot; id=&quot;frm-contactForm&quot;&gt;\n    &lt;input type=&quot;submit&quot; name=&quot;send&quot; value=&quot;Odeslat&quot;&gt;\n    &lt;input type=&quot;hidden&quot; name=&quot;_do&quot; value=&quot;contactForm-submit&quot;&gt;\n&lt;/form&gt;\n</code></pre>\n<h2 id=\"chytr-antispam-prvek\">Chytrý antispam prvek <a href=\"#chytr-antispam-prvek\">#</a></h2><p>Po krátkém úvodu (který je zcela jistě každému jasný) se přesuneme k něčemu zdánlivě jinému. Vytvoříme si chytrý antispam prvek a zjistíme, jak se bude při renderování chovat a jestli se vždy chová předvídatelně. A asi nebude překvapením, že se v určité situaci zachová moc moc špatně. Jedná se o delší kód, takže jej <a href=\"https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a\">najdete na Gistu</a>. Prakticky nejde o nic jiného, než že si vytvoříme vlastní antispam prvek. Tento prvek funguje tak, že vytvoří input ve kterém je nějaký text a pokud je k dispozici javascript, tak jej schová a smaže obsah. V tom případě je kontrola v pořádku, protože tiše předpokládá, že útočníkův robot nebude umět JS. Ačkoliv se to v dnešní době může zdát jako absurdní, tak to pořád funguje velmi dobře. Navíc přidává ještě pár honeypotů a doufá, že někde robot uvízne. Důležité je, že nijak neobtěžuje běžného návštěvníka - prostě to není vůbec vidět.</p>\n<p>Napíšeme si jednoduché rozšíření pro DI kontejner, aby bylo možné tento nový prvek používat:</p>\n<pre><code class=\"lang-php\">&lt;?php\n\nnamespace App;\n\nuse Nette\\Forms\\Form;\n\nclass HoneypotExtension extends \\Nette\\DI\\CompilerExtension\n{\n\n    public function afterCompile(\\Nette\\PhpGenerator\\ClassType $class)\n    {\n        $init = $class-&gt;methods[&#39;initialize&#39;];\n        $init-&gt;addBody(self::class . &#39;::registerControlExtensionMethods();&#39;);\n    }\n\n    public static function registerControlExtensionMethods()\n    {\n        Form::extensionMethod(&#39;addAntispam&#39;, function (Form $form, $name = &#39;honeypot&#39;, $label = &#39;Vymažte toto pole&#39;) {\n            $form[$name . &#39;_1&#39;] = new \\App\\Forms\\AntispamControl($name, $label);\n            return $form;\n        });\n    }\n\n}\n</code></pre>\n<p>Toto rozšíření samozřejmě zaregistrujeme v konfiguračním souboru:</p>\n<pre><code class=\"lang-neon\">extensions:\n    - App\\HoneypotExtension\n</code></pre>\n<p>A je to - v našem původním formuláři můžeme použít nový prvek:</p>\n<pre><code class=\"lang-php\">$form = new UI\\Form();\n$form-&gt;addAntispam();\n//...\n</code></pre>\n<p>Je to trošku magie a IDE si s tím neporadí. Proto nebude našeptávat. V tomto případě doporučuji napsat si nějakou vlastní <code>FormFactory</code>, která bude vytváře instance <code>UI\\Form</code> a do této třídy doplnit anotaci <code>@method addAntispam()</code>. Udělat si vlastní továrničku na <code>UI\\Form</code> není vůbec špatný nápad a to nejen pro antispam. Just do it.</p>\n<p>Tak a teď když máme funkční antispam a honeypoty formuláře, je čas kouknout se co se děje při renderování. Nejdříve automatické - pomocí <code>{control contactForm}</code>. Zde není co řešit. Prostě se všechny potřebná políčka vyrenderují a vše je tak, jak by mělo být. A co manuální vykreslování? Zde začíná ta nepříjemná část. Nette nemůže vědět, že by měl automaticky vykreslit i další prvky, takže je prostě nevykreslí. Praktická zkušenost je taková, že při manuálním vykreslování prostě antispam přestane fungovat. Zde se musíme ještě zasnažit.</p>\n<h2 id=\"chyt-ej-antispam-prvek\">Chytřejší antispam prvek <a href=\"#chyt-ej-antispam-prvek\">#</a></h2><p>Teď musíme jít fakt na dřeň problému. Jak vlastně funguje to automatické renderování inputu při manuálním vykreslování? Existuje něco jako třída <code>Nette\\Bridges\\FormsLatte\\Runtime</code>, která má dvě metody: <code>renderFormBegin</code> a <code>renderFormEnd</code>. Právě druhá zmíněná přidává nějaký vlastní kód a je jedno, jestli se jedná o manuální, nebo automatické renderování formuláře. To by se nám hodilo. Vytvořme si tedy vlastní <code>Runtime</code> třídu. Není potřeba aby tato třída dědila od původní. Stačí, když si vykopírujeme metodu <code>renderFormEnd</code> a lehounce pozměníme prostřední foreach:</p>\n<pre><code class=\"lang-php\">foreach ($form-&gt;getControls() as $control) {\n    if ($control-&gt;getOption(&#39;autorender&#39;) || ($control-&gt;getOption(&#39;type&#39;) === &#39;hidden&#39; &amp;&amp; !$control-&gt;getOption(&#39;rendered&#39;))) {\n        $s .= $control-&gt;getControl();\n    }\n}\n</code></pre>\n<p>Přesně tak. Všechny čáry a kouzla se aktivují, když nastavíme prvkům <code>autorender</code> (<a href=\"https://gist.github.com/mrtnzlml/95ac7726cf2788d83e3c87bc97dbef3a\">viz Gist</a>). Jenže kde se tato třída původně používala? Kde ji použijeme nyní?</p>\n<p>Řešení najdeme opět v namespace <code>Nette\\Bridges\\FormsLatte</code>, tentokrát však ve třídě <code>FormMacros</code>, která registruje formulářová makra. Vytvoříme si tedy vlastní implementaci <code>FormMacros</code> třídy, která bude dědit od původní:</p>\n<pre><code class=\"lang-php\">class FormMacros extends \\Nette\\Bridges\\FormsLatte\\FormMacros\n{\n\n    public static function install(\\Latte\\Compiler $compiler)\n    {\n        $me = new static($compiler);\n        $me-&gt;addMacro(&#39;form&#39;, [$me, &#39;macroForm&#39;], &#39;echo \\App\\Forms\\Runtime::renderFormEnd(array_pop($this-&gt;global-&gt;formsStack));&#39;);\n        $me-&gt;addMacro(&#39;formContainer&#39;, [$me, &#39;macroFormContainer&#39;], &#39;array_pop($this-&gt;global-&gt;formsStack); $formContainer = $_form = end($this-&gt;global-&gt;formsStack)&#39;);\n        $me-&gt;addMacro(&#39;label&#39;, [$me, &#39;macroLabel&#39;], [$me, &#39;macroLabelEnd&#39;], NULL, self::AUTO_EMPTY);\n        $me-&gt;addMacro(&#39;input&#39;, [$me, &#39;macroInput&#39;]);\n        $me-&gt;addMacro(&#39;name&#39;, [$me, &#39;macroName&#39;], [$me, &#39;macroNameEnd&#39;], [$me, &#39;macroNameAttr&#39;]);\n        $me-&gt;addMacro(&#39;inputError&#39;, [$me, &#39;macroInputError&#39;]);\n    }\n\n}\n</code></pre>\n<p>Důležitá je zde registrace makra <code>{form}</code>, protože to pro svojí uzavírací značku používá novou implementaci <code>Runtime</code> (tu která podporuje autorender). Zaregistrujeme:</p>\n<pre><code class=\"lang-neon\">latte:\n    macros:\n        - App\\Forms\\FormMacros::install\n</code></pre>\n<p>Smažeme cache a profitujeme. Nyní se autospam vykresluje automaticky i při manuálním renderování... :)</p>\n<p>Podobně lze samozřejmě přidat i další kontroly jako je například kontrolní součet dvou čísel, který se javascriptem předvypočte automaticky, ale s vypnutým javascriptem se zobrazí políčka pro uživatele. Řešení tohoto antispamu je také <a href=\"https://gist.github.com/mrtnzlml/961c3e2368e98aaa433e02c6603a5086\">na mém Gistu</a>. Jen je potřeba trošku rozšířit <code>HoneypotExtension</code>:</p>\n<pre><code class=\"lang-php\">public static function registerControlExtensionMethods()\n{\n    Form::extensionMethod(&#39;addAntispam&#39;, function (Form $form, $name = &#39;honeypot&#39;, $label = &#39;Vymažte toto pole&#39;) {\n        $form[$name . &#39;_1&#39;] = new \\App\\AntispamControl($name, $label);\n\n        $first = round(rand(0, 900), -2);\n        $second = rand(0, 99);\n        $validationData = self::encodeNumber($first) . &#39;;&#39; . self::encodeNumber($second);\n        $form-&gt;addHidden(&#39;validationData&#39;, $validationData)-&gt;setOmitted(TRUE)-&gt;setOption(&#39;autorender&#39;, TRUE);\n        $form[$name . &#39;_3&#39;] = new \\App\\Forms\\SumAntispamControl($first, $second, $validationData);\n\n        return $form;\n    });\n}\n\nprivate static function encodeNumber($originalNumber)\n{\n    return strtr($originalNumber, &#39;0123456789&#39;, &#39;(_.!)@-*+&amp;&#39;); //cannot contain &#39;;&#39; character\n}\n</code></pre>\n<p>Původní kód zůstává stejný, jen jsem přidal další kontrolu a zakódoval číslice tak, aby nebylo jednoduché na první pohled poznat princip tohoto antispamu. Ve fantazii se meze nekladou.</p>\n<p>A právě v tom je možná trošku problém. Zejména kvůli autorender funkci je potřeba zasahovat do vnitřností Nette a zde je již na pováženou, jestli je to dobře či nikoliv. Velké úskalí vidím v tom, že si programátor vyměňuje stavební kameny Nette za svoje trošku upravené a to nemusí být vždy hned evidentní. Pak je na zamyšlenou, jestli by nestálo za to vytvořit PR. Kdo by ale stál o takovou hovadinu... :)</p>\n"
}
