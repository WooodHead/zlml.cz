export default {
  "attributes": {
    "id": "55c2f8a2-9b13-46e2-b919-128c0c95a40d",
    "timestamp": 1427231722000,
    "title": "Generované továrničky - definitive guide",
    "slug": "generovane-tovarnicky-definitive-guide"
  },
  "body": "No dobře, možná ne úplně definitivní, ale užitečná příručka snad. Pokusím se zde rozebrat všechny potřebné stavy generovaných továrniček, které považuji za důležité a jejich co nejjednodušší zápis v configu. Jedná se hlavně o pohled z hlediska předávání parametrů. Doufám, že to ještě někdo doplní o nějaké vylepšení, nebo další příklad, abych mohl tento seznam rozšířit. To je jeden ze dvou důvodů tohoto typu článků. Ten druhý je, abych měl kam odkazovat, až se mě někdo bude opět ptát.\n\nCelkem rozebírám tyto jednotlivé případy:\n- [Předání parametru z presenteru](#toc-predani-parametru-z-presenteru)\n- [Předání parametru z konfiguračního souboru](#toc-predani-parametru-z-konfiguracniho-souboru)\n  - Metodou \"create\"\n  - Metodou \"arguments\"\n- [All in One](#toc-all-in-one)\n\n# Předání parametru z presenteru\n\nToto považuji za asi úplně nejčastější požadavek. Komponenta je jednoduchá:\n\n```php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct(array $xxx) {}\n}\n\ninterface IParameterComponentFactory {\n\n\t/** @return ParameterComponent */\n\tfunction create(array $xxx);\n\n}\n```\n\nDůležité je, že jak datový typ, tak název proměnné se musí shodovat. Config pak není o nic složitější:\n\n```neon\nservices:\n\t- IParameterComponentFactory\n```\n\nKontejner se potom vygeneruje dle očekávání:\n\n```php\nfinal class Container_59ca411ae5_IParameterComponentFactoryImpl_28_IParameterComponentFactory implements IParameterComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create(array $xxx) {\n\t\t$service = new ParameterComponent($xxx);\n\t\treturn $service;\n\t}\n\n}\n```\n\nSamotné použití je velmi jednoduché. Stačí si nechat v presenteru předat interface `IParameterComponentFactory` například pomocí anotace `@inject` a nad ním volat metodu `create`. Fígl je právě v tom, že vygenerovaný kód v kontejneru tento interface implementuje a odvádí tak zbytečnou práci za vás. Bez dalších změn lze využít autowire zaregistrovaných služeb. Předání parametru z configu a zároveň získání další závislosti pak může vypadat třeba takto (pouze upravená předchozí komponenta):\n\n```php\n<?php\n\nclass ParameterComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct(array $xxx, App\\Model\\UserManager $userManager) {}\n}\n```\n\n# Předání parametru z konfiguračního souboru\n\nToto je trošku horší, ale pořád snadno pochopitelné. Kód komponenty bude opět podobný:\n\n```php\n<?php\n\nclass ConfigComponent extends Nette\\Application\\UI\\Control {\n\tpublic function __construct($configParam) {}\n}\n\ninterface IConfigComponentFactory {\n\tfunction create();\n}\n```\n\nVšimněte si, že je v tomto případě úplně zbytečná `@return` anotace. Co má factory vytvářet lze totiž specifikovat v configu:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\nservices:\n\t- implement: IConfigComponentFactory\n\t  create: ConfigComponent(%testkey1%)\n```\n\nZde by skoro šlo přestat interface úplně psát. To ale není v současné době možné a vygenerovaný kód je pak přesně takový, jaký by měl být:\n\n```php\nfinal class Container_59ca411ae5_IConfigComponentFactoryImpl_33 implements IConfigComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create() {\n\t\t$service = new ConfigComponent('testvalue1');\n\t\treturn $service;\n\t}\n\n}\n```\n\nAlternativně lze zvolit populárnější způsob a upravit konfigurační soubor takto:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\nservices:\n\t- implement: IConfigComponentFactory\n\t  arguments: [%testkey1%]\n```\n\nVygenerovaný výsledek je stejný. V tomto případě je však nutné dát pozor na to, že při psaní interface je nutné psát jej i s `@return` anotací.\n\nOk, toto je snad jasné. Co to trošku zkomplikovat?\n\n# All in One\n\nToto snad bude dostatečně krajní případ. Pokusíme se vytvořit továrničku pro komponentu, která bude ke svému vytvoření vyžadovat parametr z configu, parametr z presenteru, službu a opět parametr z configu - vše přesně v tomto pořadí. A nebudu se v tom snažit hledat závislosti. Je vyžadováno něco takového:\n\n```php\n<?php\n\nclass AllInComponent extends Nette\\Application\\UI\\Control {\n\n\tpublic function __construct($configParam1, array $userParam, App\\Model\\UserManager $userManager, $configParam2) {}\n\n}\n\ninterface IAllInComponentFactory {\n\n\t/** @return AllInComponent */\n\tfunction create(array $userParam);\n\n}\n```\n\nJe tedy jasné, že musím vytvořit `create` metodu s parametrem, který naplním v presenteru. Zde by opět `@return` anotace nemusela být. Je úplně zbytečná. A jak na ty parametry z configu? To už je přece vyřešené viz dřívější ukázky:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\ttestkey2: testvalue2\n\nservices:\n\t- implement: IAllInComponentFactory\n\t  create: AllInComponent(configParam2: %testkey2%, configParam1: %testkey1%)\n```\n\nZde jsem si to ještě zkomplikoval tím, že jsem zadal parametry v obráceném pořadí (což by přesně takto fungovalo). Abych docílil správného pořadí, musím parametry správně pojmenovat (shodně s konstruktorem komponenty). A vygenerovaný kód? Radost pohledět:\n\n```php\nfinal class Container_59ca411ae5_IAllInComponentFactoryImpl_32 implements IAllInComponentFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Container_59ca411ae5 $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create(array $userParam) {\n\t\t$service = new AllInComponent('testvalue1', $userParam, $this->container->getService('27_App_Model_UserManager'), 'testvalue2');\n\t\treturn $service;\n\t}\n\n}\n```\n\nI v tomto případě je možné zvolit jiný (úspornější) zápis v konfiguračním souboru. Vygenerovaný výstup je opět stejný:\n\n```neon\nparameters:\n\ttestkey1: testvalue1\n\ttestkey2: testvalue2\n\nservices:\n\t- implement: IAllInComponentFactory\n\t  arguments: [configParam2: %testkey2%, configParam1: %testkey1%]\n```\n\nTeď mě nenapadá, jestli je někdy (běžně) potřeba ještě něco složitějšího. Toto jsou však dva základní přístupy zkombinované do jedné ukázky. Podívejte se na všechny tyto [příklady podrobněji na GitHubu](https://github.com/mrtnzlml/generated-factories)."
}
