export default {
  "attributes": {
    "id": "e9cd5692-13b4-495f-a63d-1dd5f4923fcb",
    "timestamp": 1356550681000,
    "title": "Návrhový vzor Singleton",
    "slug": "navrhovy-vzor-singleton"
  },
  "body": "<p>Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass Object {\n    private static $instance = null;\n    public static function getInstance() {\n        if(self::$instance === null) {\n            self::$instance = new self;\n        }\n        return self::$instance;\n    }\n}\n</code></pre>\n<p>Takovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:</p>\n<pre><code class=\"lang-php\">$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n</code></pre>\n<p>Tím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:</p>\n<pre><code class=\"lang-php\">if($obj1 === $obj2) {\n    echo &#39;$obj1 === $obj2&#39;; //TRUE\n} else {\n    echo &#39;$obj1 !== $obj2&#39;;\n}\n</code></pre>\n<p>Singleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.</p>\n<pre><code class=\"lang-php\">$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n    echo &#39;$obj1 === $obj2&#39;;\n} else {\n    echo &#39;$obj1 !== $obj2&#39;; //TRUE\n}\n</code></pre>\n<p>To je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass Object {\n    private static $instance = null;\n    public static function getInstance() {\n        if(self::$instance === null) {\n            self::$instance = new self;\n        }\n        return self::$instance;\n    }\n    protected function __construct() {}\n}\n</code></pre>\n<p>V tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!</p>\n<pre><code class=\"lang-php\">$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n    echo &#39;$obj1 === $obj2&#39;;\n} else {\n    echo &#39;$obj1 !== $obj2&#39;; //TRUE\n}\n</code></pre>\n<p>Proti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass Object {\n    private static $instance = null;\n    public static function getInstance() {\n        if(self::$instance === null) {\n            self::$instance = new self;\n        }\n        return self::$instance;\n    }\n    protected function __construct() {}\n    private function __clone() {}\n}\n</code></pre>\n<p>Pokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?</p>\n<pre><code class=\"lang-php\">$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n    echo &#39;$obj1 === $obj2&#39;;\n} else {\n    echo &#39;$obj1 !== $obj2&#39;; //TRUE\n}\n</code></pre>\n<p>To už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass Object {\n    private static $instance = null;\n    public static function getInstance() {\n        if(self::$instance === null) {\n            self::$instance = new self;\n        }\n        return self::$instance;\n    }\n    protected function __construct() {}\n    private function __clone() {}\n    private function __wakeup() {}\n}\n</code></pre>\n<p>Toto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass Object {\n    private static $instance = null;\n    public static function getInstance() {\n        if(self::$instance === null) {\n            self::$instance = new self;\n        }\n        return self::$instance;\n    }\n    protected function __construct() {}\n    public final function __clone() {\n        throw new Exception(&#39;Objekt nelze klonovat!&#39;);\n    }\n    public final function __wakeup() {\n        throw new Exception(&#39;Objekt nelze deserializovat!&#39;);\n    }\n}\n</code></pre>\n"
}
