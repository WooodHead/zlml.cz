export default {
  "attributes": {
    "id": "e9cd5692-13b4-495f-a63d-1dd5f4923fcb",
    "timestamp": 1356550681000,
    "title": "Návrhový vzor Singleton",
    "slug": "navrhovy-vzor-singleton"
  },
  "body": "Návrhový vzor Singleton je velmi známý. Má za úkol zajistit, že bude z určité třídy existovat pouze jedna instance. K této instanci poskytne globální přístupový bod. Jednoduché zadání, ale samotná implementace může být v PHP zákeřná. Proč? Tak prvně záleží na tom, jak budeme u návrhu striktní.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n}\n```\n\nTakovouto třídu lze totiž rovnou prohlásit za návrhový vzor Singleton. Dává to smysl, protože můžeme zavolat:\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = Object::getInstance();\n```\n\nTím se pokusíme vytvořit dvě instance této třídy, ve skutečnosti se však vytvoří jen jedna. Tyto objekty jsou identické, což lze dokázat jednoduchou zkouškou:\n\n```php\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2'; //TRUE\n} else {\n\techo '$obj1 !== $obj2';\n}\n```\n\nSingleton to je a nikdo nemůže říct ne. Jak jsem však již psal, záleží na tom, jak budeme u návrhu striktní, protože by to nebylo PHP, kdyby neexistovalo několik otazníků a háčků. Pravděpodobně spoustu lidí totiž napadne, že metoda <code>getInstance()</code> je sice hezká, ale vůbec ji nemusím použít. V takovém případě celý princip Singletona padá.\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = new Object();\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nTo je jasné, zatím ve třídě neexistuje žádný mechanismus, který by zakázal používání konstruktoru. K tomu je potřeba pouze malá úprava třídy.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n}\n```\n\nV tento moment již nepůjde objekt vytvořit pomocí operátoru <code>new</code>. Případný pokus skončí fatální chybou. Nebylo by to však PHP, kdyby neexistovalo několik dalších otazníků a háčků. S ledovým klidem si totiž mohu první vytvořený objekt naklonovat a tím opět získám dvě nezávislé instance jedné třídy. Ale to jsem přece nechtěl!\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = clone $obj1;\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nProti tomuto postupu se mohu bránit opět podobným způsobem jako u konstruktoru.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tprivate function __clone() {}\n}\n```\n\nPokus o naklonování již vytvořené instance pomocí metody <code>getInstance()</code> skončí opět fatální chybou. Jenže nebylo by to PHP, kdyby... Co se stane, když vytoření objekt serializuji a pak ho zase deserializuji?\n\n```php\n$obj1 = Object::getInstance();\n$obj2 = unserialize(serialize($obj1));\n\nif($obj1 === $obj2) {\n\techo '$obj1 === $obj2';\n} else {\n\techo '$obj1 !== $obj2'; //TRUE\n}\n```\n\nTo už začíná být poněkud otravné. Ale tak dobře, i to se dá ošéfovat.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tprivate function __clone() {}\n\tprivate function __wakeup() {}\n}\n```\n\nToto už sice vrátí jen warning, ale víme o tom. Schválně jsem nepsal, že se to vše dá ošetřit, protože je to spíše zákaz (popř. upozornění). Je samozřejmě možné (lepší) vracet různé vyjímky atd. Stejně tak je spousta variant jak psát přítupové modifikátory k metodám. To jednoduše vše zaleží na tom, co od Singleton objektu očekáváme a kdo objekt používá, protože jak jsem již psal, úplně klidně stačí Singleton s jednou metodou <code>getInstance()</code>. Svoji funkci plní, tečka.\n\n```php\n<?php\nclass Object {\n\tprivate static $instance = null;\n\tpublic static function getInstance() {\n\t\tif(self::$instance === null) {\n\t\t\tself::$instance = new self;\n\t\t}\n\t\treturn self::$instance;\n\t}\n\tprotected function __construct() {}\n\tpublic final function __clone() {\n\t\tthrow new Exception('Objekt nelze klonovat!');\n\t}\n\tpublic final function __wakeup() {\n\t\tthrow new Exception('Objekt nelze deserializovat!');\n\t}\n}\n```"
}
