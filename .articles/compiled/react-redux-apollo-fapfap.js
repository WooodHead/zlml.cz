export default {
  "attributes": {
    "id": "6952eca3-3942-4bfa-b68e-432772912eca",
    "timestamp": 1490538013000,
    "title": "React + Redux - Apollo =  FapFap",
    "slug": "react-redux-apollo-fapfap"
  },
  "body": "Na konci minulého roku jsem začal něco jako virtuální seriál o React vs. PHP aplikaci. Včera jsem na Poslední sobotě byl upozorněn na to, že už asi nepokračuju. To není pravda - pouze jsem je přestal číslovat... :) Po [GraphQL](2-graphql), vyřešení [N+1 problému](reseni-n-1-problemu-v-graphql), [architektuře serverové části](hexagonalni-architektura) a [omezení CSS kontextu](jak-na-lokalni-css-pro-react) v React komponentách je čas podívat se podrobněji na komunikaci se serverem.\n\nVe výsledku jsem hodně rád, že jsem to tak oddaloval, protože jsem to asi tak třikrát celé předělával a konečně mám radost z toho jak to vypadá. Veškeré kódy týkající se [frontendu](https://github.com/adeira/connector-frontend) i [backendu](https://github.com/adeira/connector) jsou jako vždy k dispozici online pod MIT.\n\n# Klientské komponenty\n\nAž do nedávné chvíle jsem na straně webového prohlížeče používal pro komunikaci se serverem knihovnu Apollo. Interně Apollo využívá Redux store a já začal hodně vážně zvažovat, že začnu Redux store využívat mnohem více. V tu chvíli už nedávalo moc velký smysl používat Apollo a přišlo mi zajímavější starat se o Redux store sám.\n\nDříve jsem Apollo používal tak, že existovala vždy nějaká nadřazená komponenta, která se dotazovala serveru a předávala data jiné komponentě. Takže jsem měl komponenty, kterým se říká kontejnery (pouze tahají data) a předávají data pro vykreslení tzv. prezentačním komponentám (pouze vykreslují, ale netahají data).\n\nMyšlenka kontejnerů a prezentačních komponent pořád zůstává. Rozdíl je teď v tom, že místo toho, aby kontejner získával data prostřednictvím Apolla, tak je připojen k Redux úložišti a v okamžiku připojení komponenty do DOMu se spustí Redux akce pro načtení dat:\n\n```javascript\nexport const AllCamerasContainer = class extends React.Component {\n\n  componentWillMount() {\n    this.props.dispatch(loadAllCameras());\n  }\n\n  render = () => { /* ... */ }\n\n};\n\nexport default connect()(AllCamerasContainer);\n```\n\nFunkce `this.props.dispatch` je k dispozici díky nadřazené komponentě, která se vytváří pripojením k Redux úložišti pomocí `connect()`.\n\nRedux funguje tak, že se pomocí funkce `dispatch` vyvolá nějaká akce/příkaz (zde načtení všech kamer), ta prolítne reducerama což jsou úplně obyčejné funkce, které umí měnit podobu stavu Redux úložiště a následně se tento nový stav uloží a komponenta se automaticky překreslí. Důležité je, že Redux si vlastně drží stav všech komponent u sebe v jednom velkém globálním úložišti a akce resp. reducery slouží pro alespoň trošku rozumné ovládání jeho obsahu. Zároveň Redux úložiště nemá z hlediska kódu **nic společného s Reactem**. Redux je ke komponentě nějak napojen, ale může fungovat úplně bez Reactu.\n\nFunkce `loadAllCameras` slouží pro vytvoření objektu reprezentující nějakou akci. Ta se potom spouští pomocí `dispatch`. Akce je obyčejný JS objekt, který si nese informaci o typu akce + nějaká další dodatečná data. Pokud však chci data teprve načíst, je nutné vytvářet místo objektu funkci, která tak učiní:\n\n```javascript\n// relies on Redux Thunk middleware\nexport const loadAllCameras = () => {\n  return dispatch => {\n\n    dispatch({ // spuštění akce (což je jen obyčejný objekt) uvnitř jiné akce\n      type: ALL_CAMERAS_LOADING,\n    });\n\n    fetch(allCamerasQuery).then(({data}) => { // funkce pro získání dat (kvůli tomu je nutný Thunk)\n\n      dispatch({ // opět jen obyčejná akce spuštěná uvnitř jiné akce\n        type: ALL_CAMERAS_LOAD_SUCCESS,\n        cameras: data.allCameras,\n      });\n\n    });\n  }\n};\n```\n\nZde začíná být vidět důvod, proč jsem opustil Apollo. Díky tomu, že mám teď v ruce veškeré akce a reducery, tak mohu pohodlně spouštět a řetězit akce jak se mi zachce. Až Redux spustí tuto akci (resp. [Redux Thunk](https://github.com/gaearon/redux-thunk)), tak si jen najde ten správný reducer (podle typu `ALL_CAMERAS_LOADING` resp. `ALL_CAMERAS_LOAD_SUCCESS`), ten upraví obsah Redux úložiště a protože máme deklarativní React, tak se data automaticky překreslí.\n\n# Server Fetcher\n\nV předchozí akci bylo vidět, že se volá funkce `fetch`. To je úplně jednoduchá funkce, která pošle na server GraphQL dotaz a vrátí odpověď (resp. Promise). Vlastně dělá jen to, že pomocí [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) položí dotaz ve správném formátu:\n\n```javascript\nreturn fetch(config.apiAddress, {\n  method: 'POST',\n  body: JSON.stringify({\n    query: graphQuery, // přichází jako argument fetcheru\n    variables: variables, // dtto\n    operationName: operationName // dtto\n  }),\n  headers\n}).then(response => response.json())\n  .then(json => {\n    return json; // zde budou příchozí data z API\n  });\n```\n\nPoskládat potřebné hlavičky je otázkou několika málo sekund:\n\n```javascript\nlet headers = {\n  Accept: '*/*',\n  'Content-Type': 'application/json'\n};\nlet token = Authenticator.getToken(); // localStorage\nif (token !== null) {\n  headers.authorization = token;\n}\n```\n\nAsi by bylo možné vracet rovnou pole `data`, které GraphQL API vrací, aby nebylo nutné dělat destructing v akcích, ale to už jsou jen kosmetické detaily.\n\nTeď by tedy mělo být zřejmé následující:\n- v Reactu existují kontejnery, což jsou komponenty, které **tahají data**\n- existují také prezentační komponenty, které **jen vykreslují data** podle `props`\n- kontejnery získávají data z Redux úložiště spuštěním akce při připojování kontejneru do DOMu (`componentWillMount`)\n- součástí spuštění akce může být načtení těchto dat do úložiště (pokud tam již nejsou)\n- na server se požadavky posílají jako jednoduchý POST s tělem obsahujícím GraphQL dotaz\n- souběžně s tělem POST požadavku je nutné odeslat také autorizační hlavičky (pokud to aplikace vyžaduje)\nOK? Možná to bylo rychlé, ale [mrkněte na kód](https://github.com/adeira/connector-frontend) a popř. si to vyzkoušejte. Nic složitého... :)\n\n# Přijetí požadavku na PHP serveru\n\nDostáváme se do oblasti, ve které [se vypastí](https://forum.nette.org/cs/28370-data-z-post-request-body-reactjs-appka-se-po-ceste-do-php-ztrati) překvapivě hodně lidí. Na straně serveru je třeba přistupovat k POST datům [trošku jinak](https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php#L62), než by mohlo být zřejmé. K této trošce teorie bude potřeba následující PHP kód:\n\n```php\n<?php\n\nvar_dump(\n  $_POST,\n  file_get_contents('php://input')\n);\n```\n\nCo se stane, pokud odešleme POST požadavek obsahující JSON třeba pomocí konzole v prohlížeči?\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"test.php\", true);\nxhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded; charset=UTF-8\");\nxhr.send(\"{a:'b'}\");\n```\n\nVrátí se tato odpoveď:\n\n```\narray(1) {\n  [\"{a:'b'}\"]=>\n  string(0) \"\"\n}\nstring(7) \"{a:'b'}\"\n```\n\nObsah `$_POST` pole může být zvláštní, ale s tím by se dalo žít. Vzhledem k tomu, že se požadavek posílá jako formulář, tak se očekává trošku jiný formát dat:\n\n```javascript\nxhr.send(\"a=1&b=2\");\n```\n\nV tomto případě pole pěkně expanduje:\n\n```\narray(2) {\n  [\"a\"]=>\n  string(1) \"1\"\n  [\"b\"]=>\n  string(1) \"2\"\n}\nstring(7) \"a=1&b=2\"\n```\n\nCo se však stane, pokud změníme hlavičku požadavku `Content-Type`?\n\n```javascript\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"test.php\", true);\nxhr.setRequestHeader(\"Content-Type\", \"application/json; charset=UTF-8\");\nxhr.send(\"a=1&b=2\");\n```\n\nPOST pole bude zcela prázdné! (nikoliv však `php://input`)\n\n```\narray(0) {\n}\nstring(7) \"a=1&b=2\"\n```\n\nJak je totiž psáno v dokumentaci, tak `$_POST` neobsahuje všechna data, která jsou na server odeslána jako POST, nýbrž:\n\n> An associative array of variables passed to the current script via the HTTP POST method **when using application/x-www-form-urlencoded or multipart/form-data as the HTTP Content-Type** in the request.\n\nDruhá polovina věty je extrémně důležitá. Také je z předchozích ukázek vidět, že jediné místo, kde jsou data k dispozici je právě input stream `php://input`. Z toho důvodu je na serveru k JSON datům nutné přistupovat rovnou přímo pomocí `file_get_contents('php://input')` (tak to dělá vnitřně `Nette/Http/RequestFactory`) nebo pomocí `$httpRequest->getRawBody()`, což je úplně to samé, jen více schované a více objektové.\n\nNyní již stačí pouze ověřit uživatele, jestli se může API vůbec ptát, získat JSON, rozparsovat dotaz a poslat jej nějaké GraphQL knihovně ať se postará o všechny strasti tohoto API. Vše je vidět v tomto jednoduchém [GraphQL endpointu](https://github.com/adeira/connector/blob/c501227a4429dba493624ca9fa85745fb5f1839c/instances/Connector/Infrastructure/Delivery/Http/GraphqlEndpoint.php).\n\nKdyby někdo prahnul po pořádné náloži uceleného textu, tak je možné sledovat [tento soubor](https://github.com/mrtnzlml/dp-latex/blob/master/main.pdf) (stále rozdělaný), který jednou začas trošku povyroste. Nějaké základní znalosti problematicky jsou nutné, ale použitý jazyk by měl být srozumitelný většině lidí. Připomínky jsou vítány, než bude pozdě... :)"
}
