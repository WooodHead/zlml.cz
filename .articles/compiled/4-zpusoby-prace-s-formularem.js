export default {
  "attributes": {
    "id": "ad9d4e96-b786-4f75-a6ca-96c85746cef7",
    "timestamp": 1488109164000,
    "title": "4 způsoby práce s formulářem v šabloně",
    "slug": "4-zpusoby-prace-s-formularem"
  },
  "body": "Velká část článků na tomto blogu jsou reakcí na nějaký reálný problém. Nehledě na to, kde jsem (třeba na včerejším [React workshopu](http://blog.id-sign.com/react-workshop/)), tak odpovídám na dotazy ohledně Nette. Je to v pořádku, rád pomůžu. Jsou však dotazy, které se neustále opakují. Toto je jeden z nich:\n\n> Formuláře v Nette jsou strašný voser. Jak to dělat lépe?\n\nVětšinou takto vágně to vždy začíná. Následuje stejné kolečko - vysvětlím proč se to tak dělá, popíšu jiný přístup k formulářům, tazatel je spokojen, podívám se do dokumentace, že to tam opravdu je a čekám na další stejný dotaz. Proto si teď dovolím vyzdvihnout nad rámec dokumentace několik základních způsobů, jak s formuláři v Nette pracovat.\n\n# První způsob - líný Ota\n\nTento způsob zná asi úplně každý. Pro superrychlé vytvoření formuláře jej stačí nadefinovat v presenteru nějak takto:\n\n```php\nprotected function createComponentComplicatedForm(): \\Nette\\Application\\UI\\Form\n{\n  $form = new \\Nette\\Application\\UI\\Form;\n  $form->addSelect('selectNo1', NULL, ['Item 1', 'Item 2']);\n  $form->addSubmit('send', 'Odeslat');\n  $form->onSuccess[] = function (\\Nette\\Application\\UI\\Form $form, \\stdClass $values) {\n    bdump($values);\n    throw new \\Nette\\NotImplementedException;\n  };\n  return $form;\n}\n```\n\nA použít v příslušné šabloně pomocí `control` makra:\n\n```\n{control complicatedForm}\n```\n\nJe to velmi jednoduché řešení a prakticky se zase až tolik nepoužívá. Většina lidí přijde poměrně rychle na to, že potřebují daleko větší flexibilitu, kterou nabízí další způsob v pořadí. Podívejme se však co se děje když se takový formulář odešle. Plyne z toho totiž jedna důležitá vlastnost, na kterou bude potřeba myslet později.\n\nFormulář se odesílá jako takový zvláštní signál s těmito POST daty:\n\n```\nselectNo1=0&send=Odeslat&_do=complicatedForm-submit\n```\n\nV průběhu životního cyklu presenteru (před `beforeRender`) dojde ke zpracování tohoto signálu. Konkrétně se nad formulářem zavolá metoda `signalReceived` resp. v případě formuláře `fireEvents`. Poměrně záhy se zavolají základní validace všech formulářových prvků. Schválně jsem v příkladu zvolil select, protože je na něm hezky vidět, že kontroluje co uživatel odeslal v selectu za hodnoty. Pokud je odeslaná hodnota k dispozici v předem nadefinovaném formuláři, tak se vybere. Co se stane pokud uživatel (záškodník) odešle něco jiného?\n\n```\nselectNo1=666&send=Odeslat&_do=complicatedForm-submit\n```\n\nV tomto případě metoda `getValue` vrátí hodnotu `NULL` a validace takového formuláře nebude úspěšná. To vyústí v chybovou hlášku `Please select a valid option.` - automaticky. Asi známá vlastnost a do chvíle než řeknu jinak bude platit.\n\n# Druhý způsob - nešťastný Karel\n\nZde se většina lidí zasekne a nádává. Protože vykreslování formuláře je v předchozím případě moc kostrbatá a vlastní PHP rendery nejsou moc nápomocné, přistoupíme k ručnímu vykreslování (místo `control` makra):\n\n```\n{form complicatedForm}\n  {input send}\n{/form}\n```\n\nUž tady si většina lidí alespoň jednou vyláme zuby (já to dělám pravidelně). Předchozí kód totiž **nebude fungovat**. Formulář se ke vší smůle sice odešle, ale neudělá vůbec nic. Pro správné fungování je nutné vykreslit všechny formulářové prvky:\n\n```\n{form complicatedForm}\n  {input selectNo1}\n  {input send}\n{/form}\n```\n\nProč? Co se děje? Tato definice formuláře totiž není správná. Nette ví, že má být ve formuláři select a má mít nějaké hodnoty, ale ty hodnoty nesedí s tím, co bylo odesláno (pamatujete?). Interně se skutečně vyhodí chyba `Please select a valid option.`, ale tu nikde nevykreslujeme, takže se zdá, že to prostě nefunguje. No fakt, vyzkoušejte si to:\n\n```html\n{form complicatedForm}\n  <ul class=\"errors\" n:if=\"$form->hasErrors()\">\n    <li n:foreach=\"$form->errors as $error\">{$error}</li>\n  </ul>\n  {*{input selectNo1}*}\n  {input send}\n{/form}\n```\n\nNa to je třeba dávat velký bacha. Tento způsob je dostatečný snad pro všechno co je potřeba. Prakticky je však nevhodný...\n\n# Třetí způsob - kodérka Silvie\n\nJe velká škoda, že o tomto způsobu neví spousta lidí co potkávám. Kodér většinou vymyslí nádhernou šablonu s formulářem (s mnohem komplikovanějším než je tento):\n\n```html\n<form action=\"\" method=\"post\" id=\"myAwesomeFormId\">\n  <select name=\"selectNo1\" id=\"myAwesomeSelectId\">\n    <option value=\"0\" selected=\"true\">Item 1</option>\n    <option value=\"1\">Item 2</option>\n  </select>\n  <input type=\"submit\" name=\"send\" value=\"Odeslat\">\n</form>\n```\n\nTeď se ale dostávám do problému, protože mám krásný formulář a měl bych jej zachovat. Mám však také jeho PHP definici a teď bych to potřeboval nějak naroubovat. Zde se stávají ty osudové chyby, kvůli kterým každý nadává - začne přepisování do druhého způsobu a hackování všeho co si kodér vymyslel. Když to dobře dopadne, tak bude formulář vypadat snad stejně jako vypadal původně. Snad...\n\nTo je ale zbytečné. Existuje lepší způsob pomocí `n:name` makra v Latte. Skutečně formulář pouze naroubujeme na ten v PHP a smažeme nepotřebné věci:\n\n```html\n<form n:name=\"complicatedForm\" id=\"myAwesomeFormId\">\n  <select n:name=\"selectNo1\" id=\"myAwesomeSelectId\"/>\n  <input n:name=\"send\"/>\n</form>\n```\n\nFormulář funguje pořád stejně, ale dokonce se i zjednodušil! No nicméně asi je z toho cítit, že pořád je na straně PHP dost práce (vlastně vešká potřebná zodpovědnost) a svoboda v šabloně je jen částečná. Zde přichází ke slovu poslední způsob.\n\n# Čtvrtý způsob - bláznivý Joe\n\nVšechno dříve zmíněné se mi nemusí líbit. Kašlu na nějaké definice v PHP, kašlu na automatické kontroly. Chci prostě vzít formulář od kodéra, odeslat ho a sám si ho zpracovat. Je to tak těžké pochopit?! Není milý Joe. Co to udělat takto - začněme s naroubouváním formuláře (ale jen fomuláře!):\n\n```html\n<form n:name=complicatedForm id=\"myAwesomeFormId\">\n  <select name=\"selectNo1\" id=\"myAwesomeSelectId\">\n    <option value=\"0\" selected=\"true\">Item 1</option>\n    <option value=\"1\">Item 2</option>\n  </select>\n  <input type=\"submit\" name=\"send\" value=\"Odeslat\">\n</form>\n```\n\nTím se zajistí, že se fomulář odešle na tu správnou adresu tou správnou metodou. Jinak jinak jsem do formuláře nezasáhl a je tedy úplně stejný, jako jej poslal kodér. Do puntíku. Veškerá data z formuláře jsou potom k dispozici zde:\n\n```php\nprotected function createComponentComplicatedForm(): \\Nette\\Application\\UI\\Form\n{\n  $form = new \\Nette\\Application\\UI\\Form;\n  $form->onSuccess[] = function (\\Nette\\Application\\UI\\Form $form) {\n    dump($form->getHttpData()); //ZDE\n  };\n  return $form;\n}\n```\n\nCo se stane, když záškodník odešle něco co by nemělo v selectu být (viz první příklad)? Přesně tak, prostě se to odešle a na serveru to přistane. Veškerá kontrola je tedy na programátorovi. K samotné hodnotě selectu je možno přistouput takto:\n\n```php\n$form->getHttpData($form::DATA_LINE, 'selectNo1')\n```\n\nTo `DATA_LINE` je vhodné pro jednořádkové vstupy, protože se na pozadí provede následující ošetření:\n\n```php\n\\Nette\\Utils\\Strings::trim(strtr($value, \"\\r\n\", '  '))\n```\n\nPořád ale platí, že může přijít ze selectu nečekaná hodnota a nelze ničemu věřit. Jedná se však o naprosto svobodný způsob, který je možné kombinovat s předchozím. Pokud tedy máte _\"neskutečně složitý formulář\"_, který je _\"už nakódovaný\"_ a jeho definice _\"má asi 500 řádek\"_ a je to _\"tak komplikované, že se v tom nikdo nevyzná\"_ a bylo by _\"lepší, kdybych si to mohl udělat sám\"_, tak vězte, že to jde.\n\n# Časté dotazy\n\n- Použil jsi to někdy ve skutečnosti? Ano.\n- Je tam nějaký problém o kterém bych měl vědět? Krom již zmiňovaného nevím o žádném. Je to prostě růčo fůčo...\n- Proč to není v dokumentaci? [Je to tam.](https://doc.nette.org/en/2.4/forms#toc-manual-rendering)\n- Proč není ten poslední způsob v dokumentaci? [Je to tam.](https://doc.nette.org/en/2.4/forms#toc-low-level-forms)\n- Tak to tedy není v české verzi! I tam [to](https://doc.nette.org/cs/2.4/forms#toc-low-level-formulare) obojí [je](https://doc.nette.org/cs/2.4/forms#toc-manualni-vykreslovani)\n- Tak to tam dřív nebylo. Je to tam [od verze 2.1](https://doc.nette.org/cs/2.1/forms), kdy se tato možnost objevila.\n- I ve staré EN verzi? [Ano](https://doc.nette.org/en/2.1/forms)\n- Šlo by to udělat i bez `getHttpData`? Ano, ale už v tom nevidím moc velký smysl.\n- Proč? To už bych mohl rovnou pracovat s `$_POST`, ale tato metoda mě pěkně odstíní a [ošetří celou řadu potřebných věcí](https://api.nette.org/2.4/source-Forms.Form.php.html#385-403).\n- Ale ve _{$frameworkName}_ se to dělá jinak a lépe! Použij tedy _{$frameworkName}_ nebo jeho podčást.\n\n:)"
}
