export default {
  "attributes": {
    "id": "bc0e2a48-6c0d-4dcb-b686-ac5eecc11c88",
    "timestamp": 1469950790000,
    "title": "Dva šablonovací systémy zároveň",
    "slug": "dva-sablonovaci-systemy-zaroven"
  },
  "body": "Možná pracujete na nějakém projektu, který používá jiný šablonovací systém než je Latte, ale Latte se vám natolik líbí, že ho chcete používat také. Nebo naopak používáte Latte, ale *<abbr title=\"Smarty? Twig? Wtf? Omg?\">[doplň název šablonovacího systému]</abbr>* se vám natolik líbí, že ho chcete používat také. A nebo prostě nemáte na výběr a musíte používat více šablonovacích systémů. V takovém případě existuje asi jediné přímočaré řešení a tím je vlastní implementace `Nette\\Application\\UI\\ITemplate`.\n\n# TemplateFactory\n\nOno to vlastně zase až tak přímočaré není. Je v tom totiž malý háček. V současné době fungují Latte šablony tak, že existuje továrna `TemplateFactory`, jejíž úkolem je vytvářet `Template` objekty. Originální implementace, kterou používá většina lidí (`Nette\\Bridges\\ApplicationLatte\\Template`) pouze deleguje renderování přímo na Latte. Nabízelo by se tedy nahradit tento objekt svým vlastním a delegovat renderování jednak na Latte a jednak třeba na Smarty. Háček je však v tom, že `Template` není služba zaregistrovaná v DIC, takže není jednoduché ji nahradit.\n\nProto aby bylo možné nahradit objekt `Template` vlastním, je nutné nahradit také `TemplateFactory`. Tento objekt vytváří nové instance třídy `Template` a tyto objekty dále nastavuje (přidává filtry, makra, proměnné, providery, prostě Nette specific věci). Nešvar s nahrazováním celé továrničky se už pár lidí [snažilo vyřešit](https://github.com/nette/application/issues/141), ale nikdy to nikdo nedotáhl do konce (včetně mě). Jak to tedy udělat teď?\n\nV první řadě je třeba vytvořit si vlastní `TemplateFactory`:\n\n```php\n<?php\n\nclass TemplateFactory implements Nette\\Application\\UI\\ITemplateFactory\n{\n\t//...\n}\n```\n\nTo v podstatě znamená copy paste původní továrny. Je to trošku nepříjemné, ale je možné z toho těžit. Můžeme se například zbavit deprecated věcí, nebo si libovolně nakonfigurovat `Template` objekt. Podstatné je, že v `createTemplate` metodě vytváříme vlastní instanci `Template` objektu.\n\nTeď přijde ta důležitá část na kterou nesmíme zapomenout. Novou vlastní `TemplateFactory` zaregistrujeme do konfiguračního souboru jako službu:\n\n```php\nservices:\n\tlatte.templateFactory: Ant\\TemplateFactory\n```\n\nTento zápis zajistí to, že se nejen `TemplateFactory` přidá do DI kontejneru, ale zároveň se nahradí původní implementace (proto to `latte.templateFactory` - důležité).\n\n# Template\n\nSamotný `Template` objekt už je pak prkotina. Stačí pouze změnit implementaci metody `render`. Já osobně jsem to řešil tak, že podle toho jaká přijde koncovka souboru, tak nabídnu ten správný engine pro vykreslení. Třeba nějak takto:\n\n```php\npublic function render($file = NULL, array $params = [])\n{\n\t$file = $file ?: $this->getFile();\n\n\tif (Strings::endsWith($file, '.latte') || $this->getLatte()->getLoader() instanceof \\Latte\\Loaders\\StringLoader) {\n\t\t//tady mám něco hustého co ukážu jindy\n\n\t\t$this->getLatte()->render($file, $params + $this->getParameters());\n   \t} else { //Smarty fallback\n   \t    //peklo které nechce nikdy vidět\n\n\t\t$providers = $this->getLatte()->getProviders();\n        /** @var \\Nette\\Application\\UI\\Presenter $presenter */\n        $presenter = $providers['uiPresenter'];\n        if ($presenter->isAjax()) {\n            $this->page->fetch($file);\n        } else {\n            $this->page->display($file);\n        }\n   \t}\n}\n```\n\nTrošku jsem to zjednodušil aby byla podtržena myšlenka. Doporučím však ještě jednu věc a to podědit si vlastní template od `Nette\\Bridges\\ApplicationLatte\\Template`. Chce to trošku si s tím pohrát, ale hlavní benefit bude vidět za chvíli. Zejména je dobré zaměřit se na `__set`:\n\n```php\npublic function __set($name, $value)\n{\n\t$this->assignToSmarty($name, $value); //DIY\n\tparent::__set($name, $value);\n}\n```\n\nTeď je totiž možné používat klasické `$this->template->variable = 'xyz';` a tato proměnná bude k dispozici bez ohledu na způsob vykreslení.\n\n# Gotchas a benefity\n\nKaždý teď tedy může používat například v komponentách `$this->template->render('***.tpl');` a zároveň mít třeba layout v Latte. Je to fuk. A to je cool. Je však třeba mít neustále na mysli, že nelze jednotlivé vykreslovací způsoby používat úplně nahodile. Styčiný bod je render metoda. Nelze tedy například používat include v Latte a vyžadovat tam šablonu ze Smarty.\n\nAsi největší nachytávka jsou snippety. Na to jak udělat podporu snippetů do Smarty se můžeme podívat jindy - není to nic složitého. Problém byl však u kombinování jednotlivých způsobů vykreslení a předávání `snippetMode` příznaku. `snippetMode` vlastně říká, jestli se má šablona vykreslit jako snippet (tedy jen podčásti) a vrátit v payloadu. Když jsem však použil komponentu ve Smarty (vlastní `{control name=test}`) a v této komponentě normální Latte šablonu obsahující snippety, tak to prostě nemohlo fungovat. Asi nejjednoušší řešení bylo v tomto případě trošku ohnout `Template` a `snippetMode` prostě přes tu aplikaci protlačit:\n\n```php\n$presenter = $this->getLatte()->getProviders()['uiPresenter'];\nif ($presenter->isAjax()) {\n\t//propagate snippet mode into components (Smarty templates):\n\tforeach ($presenter->getComponents(TRUE) as $component) {\n\t\t$component->snippetMode = $presenter->snippetMode;\n\t}\n\t$this->page->fetch($file);\n} else {\n\t$this->page->display($file);\n}\n```\n\nNení to úplně stejné jako se chová Nette k Latte, ale účel to plní dobře a to jde... :)"
}
