export default {
  "attributes": {
    "id": "827f7559-3d1a-4888-a6fb-4b421a6d7bd5",
    "timestamp": 1409409052000,
    "title": "Kdyby\\\\Console",
    "slug": "kdyby-console"
  },
  "body": "Existují knihovny, bez kterých bych si vývoj webových aplikací již téměř nedokázal představit. Jedním z nich je [Kdyby\\Console](https://github.com/kdyby/console). Již dříve jsem sice napsal článek o [Nette CliRouteru](nette-2-1-dev-clirouter), ale postupem času a hlavně také díky Doctrine jsem velmi rychle a rád přešel na jiné a dokonalejší řešení. Vzhledem k tomu, že na jednom projektu používám tuto knihovnu velmi hodně a vlastně na ní celý projekt stojí, rád bych alespoň prostřednictvím tohoto článku autorovi poděkoval ([Filip Procházka](https://github.com/fprochazka)). Zároveň bych tímto počínáním rád postupně smazával věčný problém těchto knihoven, protože většinou z hlediska návštěvníka ani není jasné, na co ta knihovna je...\n\n# Proč uvažovat o konzoli?\n\nPro mě je tato otázka celkem jednoduchá, protože mám projekty, které nejedou jen na sdíleném hostingu, ale jsou to samostatně stojící aplikace. Z toho plyne, že je často zapotřebí vykonávat pomocí CRONu velké množství úkolů. Toto je hlavní část, proč vůbec o konzolovém nástroji uvažuju. Použití je totiž velmi jednoduché a právě samotná Doctrine nabízí prostřednictvím Kdyby\\Console celou řadu klasických příkazů a je škoda je nevyužívat. Stačí spustit z příkazové řádky `php index.php` u aplikace a pokud jsou příkazy zaregistrovány v konfigu, vypíše se jejich seznam včetně nápověd:\n\n```\nC:\\xampp\\htdocs\\zeminem.cz\\www>php index.php\nNette Framework version 2.2.3-RC2\n\nUsage:\n  [options] command [arguments]\n\nOptions:\n  --help           -h Display this help message.\n  --quiet          -q Do not output any message.\n  --verbose        -v|vv|vvv Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug\n  --version        -V Display this application version.\n  --ansi              Force ANSI output.\n  --no-ansi           Disable ANSI output.\n  --no-interaction -n Do not ask any interactive question.\n\nAvailable commands:\n  help                       Displays help for a command\n  list                       Lists commands\nblog\n  blog:install               Install database schema (set-up DB credentials in config.local.neon).\n  blog:update                Update database schema (set-up DB credentials in config.local.neon).\ndbal\n  dbal:import                Import SQL file(s) directly to Database.\norm\n  orm:clear-cache:metadata   Clear all metadata cache of the various cache drivers.\n  orm:clear-cache:query      Clear all query cache of the various cache drivers.\n  orm:clear-cache:result     Clear all result cache of the various cache drivers.\n  orm:convert-mapping        Convert mapping information between supported formats.\n  orm:convert:mapping        Convert mapping information between supported formats.\n  orm:generate-entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate-proxies       Generates proxy classes for entity classes.\n  orm:generate:entities      Generate entity classes and method stubs from your mapping information.\n  orm:generate:proxies       Generates proxy classes for entity classes.\n  orm:info                   Show basic information about all mapped entities\n  orm:schema-tool:create     Processes the schema and either create it directly on EntityManager Storage Connection or generate the SQL output.\n  orm:schema-tool:drop       Drop the complete database schema of EntityManager Storage Connection or generate the corresponding SQL output.\n  orm:schema-tool:update     Executes (or dumps) the SQL needed to update the database schema to match the current mapping metadata.\n  orm:validate-schema        Validate the mapping files.\n```\nDíky této možnosti je možné rychle validovat Doctrine entity, nebo generovat SQL schéma přímo do databáze. Použití je opět jednoduché, např.: `php index.php orm:info`.\n\n# Tvorba vlastního příkazu\n\nPrvně je třeba si uvědomit, že tato knihovna je vlastně to samé jako je v [Symfony Console Component](http://symfony.com/doc/current/components/console/introduction.html), tzn. že potřebné informace se dají čerpat právě z této dokumentace a navíc existuje celá sada helperů, jako je například [Progress Bar](http://symfony.com/doc/current/components/console/helpers/progressbar.html), nebo třeba šikovný [Table](http://symfony.com/doc/current/components/console/helpers/table.html). Samotné napsání třídy (Commandu) je pak triviální záležitostí:\n\n```php\n<?php\n\nnamespace App\\Console;\n\nuse Doctrine;\nuse Entity;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass BlogInstall extends Command {\n\n\t/** @var \\Kdyby\\Doctrine\\EntityManager @inject */\n\tpublic $em;\n\n\tprotected function configure() {\n\t\t$this->setName('blog:install')->setDescription('Install database schema (set-up DB credentials in config.local.neon).');\n\t}\n\n\tprotected function execute(InputInterface $input, OutputInterface $output) {\n\t\ttry {\n        \t// Zde vykonáme vše co je potřeba\n\t\t\t// Zde vykonáme vše co je potřeba\n            // Zde vykonáme vše co je potřeba\n            //...\n\t\t\t$output->writeLn('<info>[OK] - BLOG:INSTALL</info>');\n\t\t\treturn 0; // zero return code means everything is ok\n\t\t} catch (\\Exception $exc) {\n\t\t\t$output->writeLn('<error>BLOG:INSTALL - ' . $exc->getMessage() . '</error>');\n\t\t\treturn 1; // non-zero return code means error\n\t\t}\n\t}\n\n}\n```\n\nZa povšimnutí stojí fakt, že tyto třídy jsou vedle presenterů dalším kandidátem na použití `@inject` anotace. V tomto příbadě bude tedy k dispozici příkaz `blog:install`, který je však nutné ještě zaregistrovat v konfiguračním souboru:\n\n```neon\nservices:\n\t-\n\t\tclass: App\\Console\\BlogInstall\n\t\ttags: [kdyby.console.command]\n```\n\nTento způsob registrace je jedna z věcí, která mě štve a rád bych, kdyby se toto Console naučila hackovat sama a já nemusel tagovat, že se jedná o command. Když je totiž těchto příkazů hodně, konfigurační soubor tímto způsobem poměrně rychle roste na své délce a stává se nepřehledným... (-:\n\n# A co je na tom?\n\nVždyť toto umí Symfony. To Kdyby nic jiného neumí? No, tak krom toho, že vůbec řeší integraci do Nette, což je asi hlavní úkol, tak jsou logicky součásti integrace i další části jako jsou například vlastní helpery. Není totiž nic horšího, než když v takovém commandu potřebujete presenter. Ale ono je to vlastně jednoduché:\n\n```php\n$presenter = $this->getHelper('presenter')->getPresenter();\n```\n\nA stejný problém je pak s odkazy. Jak totiž v CLI pracovat s URL, když žádná není? I to Console řeší. Stačí v configu uvést:\n\n```neon\nconsole:\n\turl: http://zlml.cz/\n```\n\nPak je tvorba odkazů v CLI úplná pohodička:\n\n```php\n$link = $presenter->link('//:Front:Homepage:default');\n```\n\nPodívejte se na [reálné ukázky](https://github.com/mrtnzlml/zlml.cz/tree/6d1ad3de5b1f98067a38d2085e4939cd17cf5db5/app/commands) příkazů pro Kdyby\\Console. Za sebe mohu tento nástroj jedině doporučit. Pokud potřebujete se svojí aplikací pracovat z příkazové řádky. Toto je jiná správná cesta. Díky! (-:"
}
