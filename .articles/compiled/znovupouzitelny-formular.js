export default {
  "attributes": {
    "id": "34ecd347-57b2-4e4f-9a99-b77edbec7df1",
    "timestamp": 1399974862000,
    "title": "Znovupoužitelný formulář",
    "slug": "znovupouzitelny-formular"
  },
  "body": "Každý kdo nějakou chvíli pracuje s Nette Frameworkem již jistě narazil na prvky, které lze použít v aplikaci opakovaně. Říkejme jim znovupoužitelné komponenty, nebo prostě jen komponenty. Následující text má za úkol ukázat opět maximálně prakticky a uceleně jedno z možných řešení jak k tomuto problému přistupovat a co se mi na tomto řešení líbí, nebo naopak nelíbí.\n\n# Motivace\n\nProč vůbec přemýšlet o komponentách? Na tuto věc má pravděpodobně dost lidí zcela jiný názor. Pro mě je havní motivací to, že si vyčistím presentery. Chci toho mít v presenterech skutečně tak akorát. Vždyť podle MVP struktury bych v presenterech neměl mít nic složitého. A pak je zde ta znovupoužitelnost. Co když se rozhodnu, že potřebuji použít stejný formulář na více místech? Přece ho nebudu kopírovat. A že takový požadavek je sice často někdo zmíní, ale prakticky není moc reálný? Ale kdepak. Zrovna nedávno jsem vytvářel mnoho stránek a na každé jsem chtěl mít právě kontaktní formulář. To je požadavek na komponentu jako dělaný...\n\n# Presenter\n\nVždy když programuji něco takového, tak se nedívám na to, jak je to správně z hlediska OOP a bůh ví čeho všeho ještě. Pro mě je v současné chvíli klíčové to, jak se dané řešení bude používat. Přesenter by tedy mohl vypadat třeba takto:\n\n```php\n<?php\n\nclass AdminPresenter extends BasePresenter {\n\n\t/** @var \\ActualityFactory @inject */\n\tpublic $actualityFactory;\n\n\tprivate $id;\n\n\tpublic function actionAktualita($id = NULL) {\n\t\t$this->id = $id;\n\t}\n\n\tprotected function createComponentForm() {\n\t\t$control = $this->actualityFactory->create($this->id);\n\t\t$control['form']->onSuccess[] = function () {\n\t\t\t$this->redirect('default');\n\t\t};\n\t\treturn $control;\n\t}\n\n}\n```\n\nMám tedy presenter, který je například pro administraci a jednu podstránku, která bude sloužit jak pro editaci aktuality, tak i pro přidání nové aktuality. Proto je parametrem *action* právě `id = NULL`. Tim totiž říkám, že může přijít jako parametr *ID* aktuality (v tom případě ji budu chtít upravovat), nebo toto *ID* nebude předáno a v tom případě bude hodnota *NULL* a budu s tím později patřičně nakládat.\n\nV poslední metodě si daný formulář vytvořím. Teoreticky by stačila pouze první řádka. Přidávám však ještě další chování do pole `onSuccess[]`, protože chci komponentu používat na více místech, ale pokaždé po úspěchu přesměrovat na jinou stránku. Zde je jedna z věcí které se mi nelíbí. A to je právě to volání `$control['form']->onSuccess[] = ...`. Musím totiž vědět jak je pojmenovaný formulář uvnitř komponenty, což mě ale je skutečnosti vůbec nezajímá. Mnohem raději bych byl třeba za zápis `$control->onSuccess[] = ...`. Chápu, že se nemusí použít komponenta pouze na fomulář, ale přesto. **Neznáte někdo lepší řešení?**\n\nA teď přijde záludná otázka. Co je to ta factory a proč jí vlastně používám?\n\n# Factory\n\nProtože v komponentách velmi často potřebuji nějaké závislosti, musím je tam nějak dostat. K tomu slouží například generované továrničky. Jedná se vlastně pouze o interface:\n\n```php\n<?php\n\ninterface IActualityFactory {\n\n\t/** @return \\Cntrl\\Actuality */\n\tpublic function create();\n\n}\n```\n\nNette se této továrničky chytí a vytvoří zhruba tento kód:\n\n```php\n<?php\n\nfinal class SystemContainer_IActualityFactoryImpl_58_IActualityFactory implements IActualityFactory {\n\n\tprivate $container;\n\n\tpublic function __construct(Nette\\DI\\Container $container) {\n\t\t$this->container = $container;\n\t}\n\n\tpublic function create() {\n\t\t$service = new Cntrl\\Actuality;\n\t\treturn $service;\n\t}\n\n}\n```\n\nZde je tedy (když bude potřeba) možné vytvořit nějaké závislosti a v metodě `create()` je komponentě předat. To vše lze udělat automaticky a Nette se o to postará. Dokonce lze předávat i parametry z konfiguračního souboru. Je to nesmírně elegantní řešení. Kdybych továrničky nepoužil, musel bych vytvářet ručně komponentu, to by ale znamenalo, že bych také musel předávat všechny závislosti ručně a jen bych si tím přidělal práci. Zkuste si vytvořit komponentu bez použití factory. Je nesmysl tahat si v presenteru nepotřebné závislosti přes presenter... Jak však předat parametry z presenteru? Netuším, jestli to lze nějak generovanou továrničku naučit, nic nám však nebrání napsat si vlastní factory:\n\n```php\n<?php\n\nclass ActualityFactory extends Nette\\Object {\n\n\tprivate $actualities;\n\n\tpublic function __construct(App\\Actualities $actualities) {\n\t\t$this->actualities = $actualities;\n\t}\n\n\tpublic function create($id) {\n\t\treturn new \\Cntrl\\Actuality($this->actualities, $id);\n\t}\n\n}\n```\n\nJe jasně vidět, že tato ručně napsaná factory vypadá velmi podobně jako automaticky vygenerovaná, ale navíc teď můžu předat metodě `create($id)` parametr, což je přesně to co potřebuji viz presenter. Chci si předat číslo aktuality a nevidím důvod proč bych to měl dělat až v komponentě. Komponenta potřebuje *ID* aktuality, ale kde ho vezme nemusí řešit. Je otázka, jestli bych si už rovnou neměl vytáhnout data z databáze v presenteru. Takto se mi to ale zatím líbí víc...\n\nRučně vytvořenou factory musíme ještě zaregistrovat v konfiguračním souboru:\n\n```neon\nservices:\n\t- ActualityFactory\n```\n\nTo je vše. Už jsme pouze krůček od funkčního formuláře.\n\n# Samotná komponenta\n\nSamotný kód komponenty už není téměř ničím zvláštní, nebo nějak nepochopitelný:\n\n```php\n<?php\n\nnamespace Cntrl;\n\nuse App;\nuse Entity;\nuse Nette\\Application\\UI;\nuse Nette;\n\nclass Actuality extends UI\\Control {\n\n\tprivate $actualities;\n\tprivate $actuality;\n\n\tpublic function __construct(App\\Actualities $actualities, $id) {\n\t\tparent::__construct();\n\t\t$this->actualities = $actualities;\n\t\t$this->actuality = $this->actualities->findOneBy(['id' => $id]);\n\t}\n\n\tpublic function render() {\n\t\t$this->template->setFile(__DIR__ . '/Actuality.latte');\n\t\t$this->template->render();\n\t}\n\n\tprotected function createComponentForm() {\n\t\t$form = new UI\\Form;\n\t\t$form->addText('headline', 'Titulek:');\n\t\t$form->addTextArea('text', 'Text:');\n\t\t$form->addSubmit('send', 'Uložit');\n\t\tif($this->actuality) { //výchozí hodnoty jen pokud aktualita již existuje\n\t\t\t$form->setDefaults(array(\n\t\t\t\t'headline' => $this->actuality->headline,\n\t\t\t\t'text' => $this->actuality->text,\n\t\t\t));\n\t\t}\n\t\t$form->onSuccess[] = $this->actualityFormSucceeded;\n\t\treturn $form;\n\t}\n\n\tpublic function actualityFormSucceeded(UI\\Form $form) {\n\t\t$values = $form->getValues();\n\t\ttry {\n\t\t\tif(!$this->actuality) { //pokud ještě neexistuje vytvořím novou entitu\n\t\t\t\t$this->actuality = new Entity\\Actuality();\n\t\t\t}\n\t\t\t$this->actuality->headline = $values->headline;\n\t\t\t$this->actuality->text = $values->text;\n\t\t\t$this->actuality->date = new \\DateTime();\n\t\t\t$this->actualities->save($this->actuality);\n\t\t\t$this->presenter->flashMessage('Aktualita byla úspěšně uložena.', 'success');\n\t\t} catch (\\Exception $exc) {\n\t\t\t$this->presenter->flashMessage($exc->getMessage(), 'danger');\n\t\t}\n\t\t//žádný redirect, až v presenteru!\n\t}\n\n}\n```\n\nV konstruktoru jednak získám nějakou modelovou třídu pro práci s databází (o to se krom factory  vůbec nestarám) a také *ID*, které přišlo z presenteru. A rovnou toto *ID* použiju k vytáhnutí si dat z databáze, protože konstruktor se spustí vždy a já také vím, že tyto data budu vždy potřebovat. V `render()` metodě pouze předám šablonu komponenty, která ve své nejprimitivnější podobě může vypada pouze takto:\n\n```\n{control form}\n```\n\nOstatně stejný kód mohu použít pro šablonu do které předávám komponentu z presenteru. Výsledkem celého snažení je tedy poměrně jednoduchý přesenter a jedna stránka na které je formulář, který zvládne jak editaci, tak vytváření nového záznamu v databázi.\n\nPoužíváte nějaké lepší (jiné) řešení? Podělte se o něj... :-)"
}
