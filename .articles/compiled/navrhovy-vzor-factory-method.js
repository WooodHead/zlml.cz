export default {
  "attributes": {
    "id": "5920d80f-a65c-40e0-9648-6a95bac6ab87",
    "timestamp": 1356648759000,
    "title": "Návrhový vzor Factory Method",
    "slug": "navrhovy-vzor-factory-method"
  },
  "body": "Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.\n\n```php\n<?php\nabstract class ACreator {\n\tprotected $attribute;\n\tpublic function __construct($attribute) {\n\t\t$this->attribute = $attribute;\n\t}\n\tabstract public function createConcreteObject();\n}\n```\n\n```php\n<?php\nclass ConcreteCreator extends ACreator {\n\tpublic function createConcreteObject() {\n\t\t$concreteObject = new ConcreteObject($this->attribute);\n\t\treturn $concreteObject;\n\t}\n}\n```\n\nAby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).\n\n```php\n<?php\nclass ConcreteObject implements IObject {\n\tprotected $attribute;\n\tpublic function __construct($attribute) {\n\t\t$this->attribute = $attribute;\n\t}\n\tpublic function test() {\n\t\techo $this->attribute;\n\t}\n}\n```\n\nPřípadně jeho rozhraní:\n\n```php\n<?php\ninterface IObject {\n\tpublic function test();\n}\n```\n\nVraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)\n\nPokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:\n\n```php\n$instance = new ConcreteObject('TEST');\n$instance->test();\n```\n\nPři zapojení továrny je použití zdánlivě složitější.\n\n```php\n$factory = new ConcreteCreator('TEST');\n$instance = $factory->createConcreteObject();\n$instance->test();\n```\n\nPřidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).\n\n```php\n// pomocí operátoru new:\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n$instance = new ConcreteObject('TEST');\n\n// pomocí továrny:\n$factory = new ConcreteCreator('TEST');\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n```\n\nA teď přidejme nový atribut - aktuální rok.\n\n```php\n// pomocí operátoru new:\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n$instance = new ConcreteObject('TEST', date('Y'));\n\n// pomocí továrny:\n$factory = new ConcreteCreator('TEST', date('Y'));\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n$instance = $factory->createConcreteObject();\n```\n\nKrom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:\n\n```php\n<?php\nclass ConcreteObject implements IObject {\n\tprotected $attribute;\n\tprotected $year;\n\tpublic function __construct($attribute, $year) {\n\t\t$this->attribute = $attribute;\n\t\t$this->year = $year;\n\t}\n\t// ...\n}\n\nabstract class ACreator {\n\tprotected $attribute;\n\tprotected $year;\n\tpublic function __construct($attribute, $year) {\n\t\t$this->attribute = $attribute;\n\t\t$this->year = $year;\n\t}\n\tabstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n\tpublic function createConcreteObject() {\n\t\t$concreteObject = new ConcreteObject($this->attribute, $this->year);\n\t\treturn $concreteObject;\n\t}\n}\n```\n\nNicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.\n\nMimochodem vzpomeňte si na [osm návrhových přikázání](osm-navrhovych-prikazani), kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje."
}
