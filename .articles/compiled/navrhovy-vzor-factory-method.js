export default {
  "attributes": {
    "id": "5920d80f-a65c-40e0-9648-6a95bac6ab87",
    "timestamp": 1356648759000,
    "title": "Návrhový vzor Factory Method",
    "slug": "navrhovy-vzor-factory-method"
  },
  "body": "<p>Návrhový vzor Factory Method má za úkol definovat rozhraní pro vytváření objektů s tím, že vlastní tvorbu instancí přenechává potomkům. Samotný návrhový vzor tedy tvoří například tyto dvě třídy.</p>\n<pre><code class=\"lang-php\">&lt;?php\nabstract class ACreator {\n    protected $attribute;\n    public function __construct($attribute) {\n        $this-&gt;attribute = $attribute;\n    }\n    abstract public function createConcreteObject();\n}\n</code></pre>\n<pre><code class=\"lang-php\">&lt;?php\nclass ConcreteCreator extends ACreator {\n    public function createConcreteObject() {\n        $concreteObject = new ConcreteObject($this-&gt;attribute);\n        return $concreteObject;\n    }\n}\n</code></pre>\n<p>Aby však tento vzor měl nějaký smysl, je potřeba ještě minimálně jedna třída od které se budou dělat instance (ConcreteObject).</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass ConcreteObject implements IObject {\n    protected $attribute;\n    public function __construct($attribute) {\n        $this-&gt;attribute = $attribute;\n    }\n    public function test() {\n        echo $this-&gt;attribute;\n    }\n}\n</code></pre>\n<p>Případně jeho rozhraní:</p>\n<pre><code class=\"lang-php\">&lt;?php\ninterface IObject {\n    public function test();\n}\n</code></pre>\n<p>Vraťme se však na začátek. Vytvářet objekty všichni umí. Slouží k tomu známý operátor <code>new</code>. Na tom není nic divného, ale jen do chvíle, než se nad tím zamyslíte. Představte si rozsáhlou aplikaci, kde na každém rohu potřebujete vytvořit instanci určitého objektu. Takže jako vždy zavoláte operátor <code>new</code> a předáte všechny potřebné argumenty. A pak se to stane. Najednou zjistíte, že nutně potřebujete přidat do konstruktoru argument/y a máte týden co dělat. K tomu se právě hodí vytvořit si továrnu na tyto instance, kdy budeme pouze volat metodu pro její vytvoření, ale to jak se vytvoří necháme na továrně. Obecně se ve světě OOP velmi často dělá, že nějakou práci prostě necháme na někom jiném. Je to funkční a pohodlný přístup. :-)</p>\n<p>Pokud tedy zapomenu na to, že existují nějaké třídy Creator, tak by použití třídy ConcreteObject vypadalo asi takto:</p>\n<pre><code class=\"lang-php\">$instance = new ConcreteObject(&#39;TEST&#39;);\n$instance-&gt;test();\n</code></pre>\n<p>Při zapojení továrny je použití zdánlivě složitější.</p>\n<pre><code class=\"lang-php\">$factory = new ConcreteCreator(&#39;TEST&#39;);\n$instance = $factory-&gt;createConcreteObject();\n$instance-&gt;test();\n</code></pre>\n<p>Přidaná hodnota tohoto postupu je však velká. Již nejsme vázání na konkrétní implementaci objektu ConcreteObject. Vlastně nás to vůbec nezajímá. Víme, že pro jeho tvorbu potřebuje továrna nějaký atribut a to, jestli pak ještě další tři přidá, nebo ne, nám může být úplně jedno. Kdo stále ještě nevěří, že je tento postup výhodný, nechť si vyzkouší vytvořit několik instancí stejného objektu (hloupý, ale názorný příklad).</p>\n<pre><code class=\"lang-php\">// pomocí operátoru new:\n$instance = new ConcreteObject(&#39;TEST&#39;);\n$instance = new ConcreteObject(&#39;TEST&#39;);\n$instance = new ConcreteObject(&#39;TEST&#39;);\n$instance = new ConcreteObject(&#39;TEST&#39;);\n$instance = new ConcreteObject(&#39;TEST&#39;);\n\n// pomocí továrny:\n$factory = new ConcreteCreator(&#39;TEST&#39;);\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n</code></pre>\n<p>A teď přidejme nový atribut - aktuální rok.</p>\n<pre><code class=\"lang-php\">// pomocí operátoru new:\n$instance = new ConcreteObject(&#39;TEST&#39;, date(&#39;Y&#39;));\n$instance = new ConcreteObject(&#39;TEST&#39;, date(&#39;Y&#39;));\n$instance = new ConcreteObject(&#39;TEST&#39;, date(&#39;Y&#39;));\n$instance = new ConcreteObject(&#39;TEST&#39;, date(&#39;Y&#39;));\n$instance = new ConcreteObject(&#39;TEST&#39;, date(&#39;Y&#39;));\n\n// pomocí továrny:\n$factory = new ConcreteCreator(&#39;TEST&#39;, date(&#39;Y&#39;));\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n$instance = $factory-&gt;createConcreteObject();\n</code></pre>\n<p>Krom toho, že by mě za chvíli přestalo bavit do každého konstruktoru kopírovat nový atribut, tak jsem také mohl udělat o hodně více chyb než u továrny. Pravdou je, že jsem musel upravit ještě pár tříd:</p>\n<pre><code class=\"lang-php\">&lt;?php\nclass ConcreteObject implements IObject {\n    protected $attribute;\n    protected $year;\n    public function __construct($attribute, $year) {\n        $this-&gt;attribute = $attribute;\n        $this-&gt;year = $year;\n    }\n    // ...\n}\n\nabstract class ACreator {\n    protected $attribute;\n    protected $year;\n    public function __construct($attribute, $year) {\n        $this-&gt;attribute = $attribute;\n        $this-&gt;year = $year;\n    }\n    abstract public function createConcreteObject();\n}\n\nclass ConcreteCreator extends ACreator {\n    public function createConcreteObject() {\n        $concreteObject = new ConcreteObject($this-&gt;attribute, $this-&gt;year);\n        return $concreteObject;\n    }\n}\n</code></pre>\n<p>Nicméně křivka výhod při používání továrny velmi rychle překoná svým stoupáním křivku lenosti při používání operátoru new.</p>\n<p>Mimochodem vzpomeňte si na <a href=\"osm-navrhovych-prikazani\">osm návrhových přikázání</a>, kde se také říká, že máme vždy programovat vůči rozhraní, a nikdy ne vůči konkrétní implementaci, což tento návrhový vzor perfektně splňuje.</p>\n"
}
