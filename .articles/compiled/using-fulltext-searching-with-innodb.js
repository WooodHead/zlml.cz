export default {
  "attributes": {
    "id": "30938e58-9de3-403e-a862-493564630ddd",
    "timestamp": 1375126671000,
    "title": "Using fulltext searching with InnoDB",
    "slug": "using-fulltext-searching-with-innodb"
  },
  "body": "Sometimes is quite useful to use InnoDB engine. \nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \nYou can't create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \nUnfortunately you can't create foreign keys on MyISAM. It's starting to be quite embarassing. \nLet me show you how to search via fulltext on InnoDB tables.\n\nIn fact it's not possible to use fulltext index on InnoDB tables, \nbut there is possible workaround. At first you need a classic InnoDB structure. \nFor example database of  blog:\n\n```sql\nSET NAMES utf8;\nSET foreign_key_checks = 0;\nSET time_zone = 'SYSTEM';\nSET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';\n\nDROP TABLE IF EXISTS `posts`;\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  `date` datetime NOT NULL,\n  `release_date` datetime NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `title_3` (`title`(200))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `tags`;\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) NOT NULL,\n  `color` varchar(6) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `posts_tags`;\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) NOT NULL,\n  `post_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tag_id` (`tag_id`),\n  KEY `post_id` (`post_id`),\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\nNow we have pretty simple database structure with InnoDB tables with foreign keys. \nIt would be nice to be able search on database table **posts** using fulltext search:\n\n```sql\nSELECT *\nFROM posts\nWHERE MATCH(title, body) AGAINST ('something' IN BOOLEAN MODE);\n```\n\nBut it is not possible. It returns something like:\n>   Error in query: The used table type doesn't support FULLTEXT indexes\n\nLet's create another one table with triggers and fulltext indexes. \nWe need to create mirror table. For example:\n\n```sql\nDROP TABLE IF EXISTS `mirror_posts`;\nCREATE TABLE `mirror_posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  PRIMARY KEY (`id`),\n  FULLTEXT KEY `title_body` (`title`,`body`),\n  FULLTEXT KEY `title` (`title`),\n  FULLTEXT KEY `body` (`body`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n```\n\nAnd than we need to create triggers:\n\n```sql\nDELIMITER ;;\n\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\n\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\nUPDATE mirror_posts SET\n    id = NEW.id,\n    title = NEW.title,\n    body = NEW.body\nWHERE id = OLD.id;;\n\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\nDELETE FROM mirror_posts WHERE id = OLD.id;;\n```\n\nIt means, that we copy all of events and data from table **posts** to the table **mirror_posts**.\nFinally we can use more complex fulltext search feature:\n\n```sql\nSELECT *\nFROM mirror_posts\nWHERE MATCH(title, body) AGAINST ('something' IN BOOLEAN MODE)\nORDER BY 5 * MATCH(title) AGAINST ('something') + MATCH(body) AGAINST ('something') DESC;\n```\n\nAs I said, this is just workaround, not solution. \nSometimes it's bad practice, because you need copy of indexed columns. \nBut it works. And for small blogs it's sufficient."
}
