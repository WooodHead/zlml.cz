export default {
  "attributes": {
    "id": "30938e58-9de3-403e-a862-493564630ddd",
    "timestamp": 1375126671000,
    "title": "Using fulltext searching with InnoDB",
    "slug": "using-fulltext-searching-with-innodb"
  },
  "body": "<p>Sometimes is quite useful to use InnoDB engine. \nUnfortunately InnoDB is good for tables with foreign keys, but useless for fulltext search. \nYou can&#39;t create fulltext index on InnoDB tables, but you can create this index on MyISAM tables. \nUnfortunately you can&#39;t create foreign keys on MyISAM. It&#39;s starting to be quite embarassing. \nLet me show you how to search via fulltext on InnoDB tables.</p>\n<p>In fact it&#39;s not possible to use fulltext index on InnoDB tables, \nbut there is possible workaround. At first you need a classic InnoDB structure. \nFor example database of  blog:</p>\n<pre><code class=\"lang-sql\">SET NAMES utf8;\nSET foreign_key_checks = 0;\nSET time_zone = &#39;SYSTEM&#39;;\nSET sql_mode = &#39;NO_AUTO_VALUE_ON_ZERO&#39;;\n\nDROP TABLE IF EXISTS `posts`;\nCREATE TABLE `posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  `date` datetime NOT NULL,\n  `release_date` datetime NOT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `title_3` (`title`(200))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `tags`;\nCREATE TABLE `tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(50) NOT NULL,\n  `color` varchar(6) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nDROP TABLE IF EXISTS `posts_tags`;\nCREATE TABLE `posts_tags` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `tag_id` int(11) NOT NULL,\n  `post_id` int(11) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `tag_id` (`tag_id`),\n  KEY `post_id` (`post_id`),\n  CONSTRAINT `posts_tags_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `tags` (`id`),\n  CONSTRAINT `posts_tags_ibfk_2` FOREIGN KEY (`post_id`) REFERENCES `posts` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n</code></pre>\n<p>Now we have pretty simple database structure with InnoDB tables with foreign keys. \nIt would be nice to be able search on database table <strong>posts</strong> using fulltext search:</p>\n<pre><code class=\"lang-sql\">SELECT *\nFROM posts\nWHERE MATCH(title, body) AGAINST (&#39;something&#39; IN BOOLEAN MODE);\n</code></pre>\n<p>But it is not possible. It returns something like:</p>\n<blockquote>\n<p>  Error in query: The used table type doesn&#39;t support FULLTEXT indexes</p>\n</blockquote>\n<p>Let&#39;s create another one table with triggers and fulltext indexes. \nWe need to create mirror table. For example:</p>\n<pre><code class=\"lang-sql\">DROP TABLE IF EXISTS `mirror_posts`;\nCREATE TABLE `mirror_posts` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `title` text NOT NULL,\n  `body` text NOT NULL,\n  PRIMARY KEY (`id`),\n  FULLTEXT KEY `title_body` (`title`,`body`),\n  FULLTEXT KEY `title` (`title`),\n  FULLTEXT KEY `body` (`body`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n</code></pre>\n<p>And than we need to create triggers:</p>\n<pre><code class=\"lang-sql\">DELIMITER ;;\n\nCREATE TRIGGER `insert_posts` AFTER INSERT ON `posts` FOR EACH ROW\nINSERT INTO mirror_posts VALUES (NEW.id, NEW.title, NEW.body);;\n\nCREATE TRIGGER `update_posts` AFTER UPDATE ON `posts` FOR EACH ROW\nUPDATE mirror_posts SET\n    id = NEW.id,\n    title = NEW.title,\n    body = NEW.body\nWHERE id = OLD.id;;\n\nCREATE TRIGGER `delete_posts` AFTER DELETE ON `posts` FOR EACH ROW\nDELETE FROM mirror_posts WHERE id = OLD.id;;\n</code></pre>\n<p>It means, that we copy all of events and data from table <strong>posts</strong> to the table <strong>mirror_posts</strong>.\nFinally we can use more complex fulltext search feature:</p>\n<pre><code class=\"lang-sql\">SELECT *\nFROM mirror_posts\nWHERE MATCH(title, body) AGAINST (&#39;something&#39; IN BOOLEAN MODE)\nORDER BY 5 * MATCH(title) AGAINST (&#39;something&#39;) + MATCH(body) AGAINST (&#39;something&#39;) DESC;\n</code></pre>\n<p>As I said, this is just workaround, not solution. \nSometimes it&#39;s bad practice, because you need copy of indexed columns. \nBut it works. And for small blogs it&#39;s sufficient.</p>\n"
}
