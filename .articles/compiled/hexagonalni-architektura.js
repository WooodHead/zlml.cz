export default {
  "attributes": {
    "id": "97b1917b-d6ed-4305-a543-3bdde9b298c9",
    "timestamp": 1487322556000,
    "title": "Hexagonální architektura",
    "slug": "hexagonalni-architektura"
  },
  "body": "Struktura webových aplikací je něco, co se neustále mění a stejně s programátorem i zdokonaluje. Před více než rokem jsem se o jedné z možných struktur PHP aplikace [trošku rozepsal](jeste-lepsi-struktura-nette-aplikace). A teď si ukážeme další alternativu, která je [k proklikání zde](https://github.com/adeira/connector/tree/2169296c8da4a50bf4f928e94e756f3b23afea24). Nejedná se o nic převratného. Tento přístup mě však v poslední době hodně baví a dá se na něm naučit zase něco nového. Jedná se vlastně o tento adresářový strom (zjednodušeně):\n\n```\n.\n├── bin/            ...  pomocné SH skripty\n├── config/         ...  globální konfigurace aplikace\n├── migrations/     ...  dopředné DB migrace\n├── src/\n├── tests/          ...  veškeré testy\n├── var/            ...  logy a temp\n├── vendor/         ...  balíčky třetích stran\n├── www/            ...  veřejná složka\n├── bootstrap.php   ...  vytváření DI kontejneru\n├── composer.json   ...  definice závislostí třetích stran\n├── composer.lock\n├── LICENSE.txt\n└── README.md\n```\n\nNa první pohled je asi vše jasné. Struktura je téměř identická s tím, co je běžné u začínajících Nette projektů (Nette zde však není vůbec důležité). Za povšimnutí stojí pouze to, že `bootstrap.php` a globální konfigurace jsou na úrovni kořenového adresáře, takže neexistuje žádná složka `app`. Zůstává tedy otázka - kde jsou veškeré kódy a jak je aplikace členěna?\n\n# Kontexty\n\nVeškerá zábava je právě ve složce `src` (jak se asi dalo čekat):\n\n```\nsrc/\n├── Authentication/\n├── Common/\n├── Devices/\n├── Endpoints/\n└── Routing/\n```\n\nOsobně mám pořád problém s pojmenováváním věcí, takže mám pořád takový pocit, že jednotlivé kontexty nejsou dobře zaškatulkované. To ale není zase až tak důležité. Důležitá je následující myšlenka: každá tato podsložka (kontext) se stará o úplně všechno. Od konfigurací, přes presentery až po business logiku. Uvnitř kontextu nejsou pouze balíčky třetích stran a testy (ty jsou v `tests`, ale mají úplně stejnou adresářovou strukturu - ne nutně soubory).\n\nJe třeba trošku se pozastavit nad konfigurací. Každý balíček si s stebou nese vlastní konfigurační soubory, které potřebuje k životu. Ty většinou velmi úzce souvisejí např. s konfigurací DI kontejneru. Ale pouze pro potřeby daného kontextu! Pokud je třeba tento balíček konfigurovat na globální úrovni celé aplikace, pak je tento balíček zaregistrován jako DI rozšíření. Tato úprava myšlení nad konfigurací je možná díky balíčku [adeira/compiler-extension](https://github.com/adeira/compiler-extension). Doporučuji alespoň přečíst a doufat, že to bude fungovat i v Nette 3 ([Proč by nemohlo?](https://github.com/nette/di/issues/143)).\n\nSamostatná interní konfigurace kontextu je asi to nejdůležitější pro pokračování (může být také pěkně [dlouhá a komplikovaná](https://github.com/adeira/connector/blob/2169296c8da4a50bf4f928e94e756f3b23afea24/src/Devices/Infrastructure/DI/Nette/config.neon)). Co obsahuje takový kontext (balíček)?\n\n```\nsrc/Devices/\n├── Application/\n│   ├── Exceptions/\n│   └── Service/\n├── DomainModel/\n│   └── WeatherStation/\n└── Infrastructure/\n    ├── Delivery/\n    ├── DI/\n    ├── DomainModel/\n    └── Persistence/\n```\n\nTo už je o něco zajímavější a také řádově komplikovanější na pochopení. Dále se totiž dělí aplikace na tři důležité části, kde každá má jiný význam a každá si tedy zaslouží krátký komentář. Začněme pěkně uprostřed.\n\n# Doménová vrstva\n\nV doménové vrstvě je pouze obyčejné PHP. Myšlenka je taková, že se zde budu soustředit pouze na návrh modelu v čistém PHP a nebudu to nijak komplikovat zanášením jakýchkoliv frameworků či jiných externích knihoven:\n\n```\nsrc/Devices/DomainModel/\n├── WeatherStation\n│   ├── IAllWeatherStationRecords.php\n│   ├── IFileLoader.php\n│   ├── WeatherStationId.php\n│   ├── WeatherStation.php\n├── Humidity.php\n├── PhysicalQuantities.php\n├── Pressure.php\n├── Temperature.php\n└── Wind.php\n```\n\nNikde zde nenajdete v kódu slovo Nette, Symfony nebo třeba Doctrine (_ve skutečnosti to tam je, ale to je chyba_). Jsou to prostě úplně obyčejné objekty, které mají za úkol řešit nějaký konkrétní problém onoho konkrétního kontextu a nic víc. Díky tomu je psaní testů na tuto část aplikace naprosto triviální. Když někde existuje nějaká závislost, tak je zprostředkována pomocí rozhraní, takže vyměnit implementaci v testech je díky tomuto striktnímu rozdělení opravdu hračka.\n\nTakto by však aplikace sama o sobě nefungovala. Je potřeba mít zde vazbu na konkrétní implementaci, na konkrétní framework či knihovnu. Od toho slouží další vrstva.\n\n# Infrastrukturní vrstva\n\nZde není nic jiného, než implementace (implementační detaily). Většinou se jedná o třídy, které nemají žádnou zvláštní nebo složitou logiku. Slouží pouze jako napojení na framework a jako implementace rozhraní z domménové vrstvy. To se silně projeví ve struktuře:\n\n```\nsrc/Devices/Infrastructure/\n├── Delivery/\n│   ├── API/\n│   │   └── GraphQL/\n│   ├── Console/\n│   │   └── Symfony/\n│   └── Http/\n│       └── Nette/\n├── DI/\n│   └── Nette/\n│       ├── config.neon\n│       └── Extension.php\n├── DomainModel/\n│   └── WeatherStation/\n│       ├── Doctrine/\n│       └── Series/\n└── Persistence/\n    ├── Doctrine/\n    │   ├── Mapping/\n    │   └── DoctrineAllWeatherStations.php\n    └── InMemory/\n        └── InMemoryAllWeatherStations.php\n```\n\nTrošku se to komplike, že? Po chvilce studování to však dává celé smysl. Tak třeba `Delivery` - je potřeba doručit nějakou šablonu prostřednictvím presenteru, poslat JSON nebo komunikovat s CLI. Proto je zde vždy vazba na konkrétní technologii (o tom ostatně celá tato vrstva je). Podobně napojení na DI. Může se zdát, že to vždy bude Nette, ale pokud bych podobným stylem vydával i Composer knihovny, tak je jednoduché dodělat podporu i pro další frameworky - kód je na to připraven.\n\nAsi nejzajímavější je potom složka `Persistence`, která řeší ukládání dat _někam_. V mém případě je to primárně Doctrine, takže se zde musím hodně zasnažit, abych dokázal dříve vytvořené objekty uložit do databáze a přitom o tom žádný z těchto objektů netušil (občas dřina, ale všechno jde). Ale implementací může být více - třeba v obyčejné paměti PHP. Což je super strategie pro testování. V testech (pokud to není smyslem toho testu) nepotřebuji pracovat přímo s pomalou databází, takže nahradit její implementaci za ukládání do paměti bude super rychlé.\n\nZbývá poslední vrstva.\n\n# Aplikační vrstva\n\nMít takto myšlenkově oddělené závislosti jednotlivých částí aplikace má spoustu výhod. Důležité je zeptat se: jak budeme tento model ovládat? Odpovědí je právě aplikační vrstva. Ta má za úkol pouze jednu věc. Zpřístupnit doménovou vrstvu širokému okolí. Pokud tedy presenter chce komunikovat s doménovou vrstvou, musí prostřednictvím aplikační vrstvy. Proč musí? Nestačilo by rovnou používat nějaký interface pro repozitář? Stačilo, ale to není dobrý nápad!\n\nRovnou pracovat s repozitáři není rozumné, protože ty maximálně tahají data z úložiště. To je jejich zodpovědnost, ale co třeba oprávnění a transakce? O to se právě stará aplikační vrstva. Jako příklad budeme chtít vytvořit záznam pro novou meteostanici. Zde konkrétně využívám přístup CQS (Command-Query Separation). Zde existují dva způsoby jak komunikovat. Pomocí dotazů, kdy každý dotaz vrací požadovanou informaci, ale **nemodifikuje data** a pomocí příkazů, které data modifikují, ale **nevrací žádná data zpět**.\n\nTakový příklaz by se mohl jmenovat `CreateWeatherStation` a jedná se pouze o obyčejný DTO objekt, který nemá žádnou logiku a měl by být tak jednoduchý, že jej není třeba testovat (pokud nechcete). Je to fakt jenom přepravka na data. Tento příkaz má svého parťáka, který jej umí zpracovat. Příkaz odesílám pomocí sběrnice třeba z API:\n\n```php\n$this->commandBus->dispatch(new CreateWeatherStation(\n    WeatherStationId::create(), // ID nové stanice\n    $args['name'], // název stanice\n    $context->userId() // ID uživatele, který vytváří stanici\n));\n```\n\nTato sběrnice jednak doručí příkaz na to správné místo pro zpracování, ale také obstará databázové transakce, prokud je to nutné. Tento příkaz se zpracuje v `handleru`, který implementuje metodu `__invoke` (nebo cokoliv jiného co je `callable`):\n\n```php\npublic function __invoke(CreateWeatherStation $aCommand)\n{\n    $owner = $this->ownerService->existingOwner($aCommand->userId());\n\n    $this->weatherStationRepository->add(new WeatherStation(\n        $aCommand->stationId(),\n        $owner,\n        $aCommand->name(),\n        new \\DateTimeImmutable('now')\n    ));\n}\n```\n\nKouzlo je v tom, že je zde ukryta i kontrola ověření, protože na prvním řádku se snažím získat z uživatele vlastníka (jinak exception) a samotná meteostanice také chce v konstruktoru vlastníka (nikoliv jen uživatele). Kontrolu tedy nejde zapomenout. `weatherStationRepository` je zde opět jen interface. Jak je vidět, tak je zde hodně věcí na které se nesmí zapomenout a proto je rozumné přistupovat k doménovému modelu pouze přes tuto aplikační vrstvu.\n\nNa závěr nutno jednu drobnou poznámku. Tento přístup (hledejte pod názvem hexagonální architektura) mě moc baví a pořád je co se zde učit nového. Pokud však patříte do kategorie \"líný programátor\", pak pro vás tento přístup určitě není vhodný. Je to totiž spousta práce, která se může zdát jako zbytečná. Klidně se to vše nechá dělat jednoduše v jedné vrstvě. Hexagonální architektura však nabízí elegantní řešení problémů, které občas ve vývoji nastanou a myslím si, že hledí hodně vpřed. Doporučuji tedy alespoň jednou vyzkoušet a pokud nic jiného, tak si z toho alespoň odnést některé myšlenky, které člověka posunou zase o kousek dál... :)"
}
