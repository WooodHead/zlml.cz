export default {
  "attributes": {
    "id": "334c8bae-af8a-4b17-9735-dfba909f5fa1",
    "timestamp": 1447611844000,
    "title": "Od indexu až po presenter",
    "slug": "od-indexu-az-po-presenter"
  },
  "body": "Když jsem se učil pracovat s Nette Frameworkem, musel jsem v začátcích hodně přivírat oči a říkat si \"prostě to tak je\". Hodně věcí bylo zahaleno do tmy. Teď už to tak naštěstí není, ale stále se stává, že mi někdo napíše a děkuje za poodhalení a vysvětlení toho, jak to funguje na pozadí (za což zase děkuji já). Pokusím se tedy pokračovat a vrátím se na úplný začátek - do `index.php` a poodhalím, jak probíhá start takové běžné aplikace. A jako vždy - co nejjednodušeji.\n\nZodpovím (nebo alespoň nastíním odpovědi na) následující otázky:\n- proč redirect vyvolává AbortException\n- jak napsat vlastní NanoPresenter\n- proč má Nette dva request objekty\n- kde se bere životní cyklus presenteru\n\n# Start aplikace\n\nNedávno jsem dostal v práci na starost implementovat Nette do jednoho legacy projektu. Už jsem tu o tom [psal](navrhovy-vzor-legacy-code). Byl to nesmírně vyčerpávající úkol, ale už mám hotovo a jsem ve fázi nekonečného refaktoringu. Jednou z prvních věcí, které bylo nutné vyřešit byl start aplikace z jednoho místa. Toto naštěstí řeší [web-project](https://github.com/nette/web-project) (nebo [sandbox](https://github.com/nette/sandbox) chcete-li) už v základu takto (`.htaccess`):\n\n```\n<IfModule mod_rewrite.c>\n\tRewriteEngine On\n\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule !\\.(pdf|js|ico|gif|jpg|png|css|rar|zip|tar\\.gz|map)$ index.php [L]\n</IfModule>\n```\n\nČímž se velmi rychle dostáváme k prvnímu bodu, kterým je `index.php`:\n\n```php\n/** @var \\Nette\\DI\\Container $container */\n$container = require __DIR__ . '/../app/bootstrap.php';\n/** @var \\Nette\\Application\\Application $application */\n$application = $container->getByType(\\Nette\\Application\\Application::class);\n$application->run();\n```\n\nV tomto souboru vše začíná a také končí. Totiž zavolá se ještě minimálně `\\Tracy\\Debugger::shutdownHandler`, `\\Nette\\Http\\Session::clean` a `\\Nette\\Http\\Response::__destruct`, ale zůstaňme u toho, že zde vše začíná a také končí. O co v indexu vlastně jde? Hned přeskočím první řádku, ačkoliv se jedná o nezanedbatelnou část. Z bootrapu získáme hotovou instanci [DIC](https://doc.nette.org/cs/2.3/dependency-injection), resp. přímého potomka. Následuje vytažení [Application](https://api.nette.org/2.3.7/Nette.Application.Application.html) a naškytnutí aplikace pomocí metody `run`. To je předpokládám všem jasné, proto jsem to vzal letem světem. Cílem tohoto článku je však popsání právě `run` metod.\n\n# Run, run!\n\nMetoda `\\Nette\\Application\\Application::run` vypadá přesně takto:\n\n```php\npublic function run()\n{\n    try {\n        $this->onStartup($this);\n        $this->processRequest($this->createInitialRequest());\n        $this->onShutdown($this);\n    } catch (\\Exception $e) {\n        $this->onError($this, $e);\n        if ($this->catchExceptions && $this->errorPresenter) {\n            try {\n                $this->processException($e);\n                $this->onShutdown($this, $e);\n                return;\n            } catch (\\Exception $e) {\n                $this->onError($this, $e);\n            }\n        }\n        $this->onShutdown($this, $e);\n        throw $e;\n    }\n}\n```\n\nPro přehlednost to ještě zjednoduším a vyhodím vše, co pro samotné spuštění aplikace není nezbytně nutné:\n\n```php\npublic function run()\n{\n    try {\n        $this->processRequest($this->createInitialRequest());\n    } catch (\\Exception $e) {\n        if ($this->catchExceptions && $this->errorPresenter) {\n            $this->processException($e);\n            return;\n        }\n        throw $e;\n    }\n}\n```\n\nMoc toho opět nezbylo. Vlastně se zde dějí jen tři věci. Prvně [createInitialRequest](https://api.nette.org/2.3.7/source-Application.Application.php.html#102-124). Tato metoda vrátí (jak už název napovídá) tzv. aplikační request. To je objekt, který pak putuje celou aplikací a nese si informaci o tom co vlastně uživatel chce. Vzpomínáte si na článek o [dynamickém routování URL adres](dynamicke-routovani-url-adres)? Tam jsem ukazoval, jak se HTTP request změní právě na aplikační a zpět. Celá sranda se tedy odehrává někde v RouterFactory (zatím to platí, do budoucna ale [nebude](https://github.com/nette/routing/commit/e802a85e96f5814ddf1a16ea1517398eb560bab6)). Samotný HTTP request se pak dostane do `Application` díky DI. Už v `createInitialRequest` je tedy jasné, jestli je možné požadavek přeložit, nebo 404. Pokud 404, tak konec, resp. `processException` pokud je to v configu zapnuté (což jinými slovy znamená forward na error presenter):\n\n```neon\napplication:\n    catchExceptions: yes\n```\n\nPokud se však povede získat aplikační request, nastupuje funkce `processRequest`. Mrkněte na [implementaci](https://api.nette.org/2.3.7/source-Application.Application.php.html#127-150). Opět se nejedná o nic složitého. Jde zde vlastně jen o jedinou věc. Získat presenter a zavolat nad ním `run`. Proč `run`? Presenter totiž není potomek `\\Nette\\Application\\UI\\Presenter` jak si pamatují skoro všichni, ale spíše objekt, který implementuje interface `\\Nette\\Application\\IPresenter` jehož jedinou metodou je právě `run` do které se jako jediný parametr předává již zmíněný aplikační request. Zároveň musí tato metoda vracet `\\Nette\\Application\\IResponse`.\n\nZ toho plyne, že pokud potřebujeme velmi jednoduchý presenter (který skoro nic neumí, ale je rychlý), stačí si implementovat `IPresenter` rozhraní a hotovo:\n\n```php\nclass NanoPresenter extends Nette\\Object implements Nette\\Application\\IPresenter\n{\n\n\tpublic function run(Nette\\Application\\Request $appRequest)\n\t{\n\t\treturn new Nette\\Application\\Responses\\TextResponse('It works!');\n\t}\n\n}\n```\n\nV běžném presenteru se toho však děje samozřejmě mnohem více. Právě v metodě `run` se schovává celý dobře známý životní cyklus presenteru. Než se však dostanu k reálnému příkladu, začnu na tomto jednoduchém. `NanoPresenter` vrací pouze `TextResponse` s obyčejným textem. Tato odpověď je předána zpět do `processRequest` a následně je hned zavoláno `\\Nette\\Application\\IResponse::send` což v tomto konkrétním případě vyústí v obyčejné echo. Co se však děje v běžném presenteru?\n\n# Vykreslení šablony\n\nPresenter, který dědí od `\\Nette\\Application\\UI\\Presenter` dělá téměř to samé. Jediný rozdíl je v tom, že presenter vlastně vykreslitelná komponenta, takže si vezme šablonu a předá ji stejně jako v předchozím případě do `TextResponse`. Zde je oproti mému `NanoPresenter` příkladu malý implementační rozdíl, ale ve výsledku presenter tak jako tak `TextResponse` vrátí zpět `Application` objektu do `processRequest` metody. Dále se opět zavolá `\\Nette\\Application\\Responses\\TextResponse::send`, tentokrát však nedojde k obyčejnému echu, ale spustí se renderování předané šablony (`\\Nette\\Application\\UI\\ITemplate`). Většinou to tedy propadne na Latte, ale to samozřejmě není podmínkou.\n\n```php\npublic function send(Nette\\Http\\IRequest $httpRequest, Nette\\Http\\IResponse $httpResponse)\n{\n    if ($this->source instanceof Nette\\Application\\UI\\ITemplate) {\n        $this->source->render();\n    } else {\n        echo $this->source;\n    }\n}\n```\n\nZ předchozího textu by mělo být zřejmé, kudy požadavek putuje. Když si prohlédnete detailněji to co jsem zde popsal, mělo by být jasné, že se interně používá `\\Nette\\Application\\AbortException` a proto je nebezpečné v presenterech chytat bezmyšlenkovitě všechny výjimky. Nikdo pak nechce řešit \"proč to Nette zase nepřesměrovává\".\n\nTento text by měl překlenout tu temnou propast mezi `index.php` a akcí v presenteru. Příště už se snad vrhnu na něco zajímavějšího... :)"
}
