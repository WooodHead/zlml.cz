export default {
  "attributes": {
    "id": "0939f66b-9d4b-4646-b787-76fa294fd2c4",
    "timestamp": 1353707019000,
    "title": "Výpočet mediánu",
    "slug": "vypocet-medianu"
  },
  "body": "# Zadání\n\n\nNajděte v dostupné literatuře nebo vymyslete co nejlepší algoritmus pro výpočet mediánu.\nNezapomeňte na citaci zdrojů. Kritéria kvality v sestupném pořadí jsou: výpočetní složitost, \njednoduchost a implementační nenáročnost, paměťová spotřeba.\n\n# Definice\n\n\nMedián je hodnota, která dělí seřazenou posloupnost na dvě stejně velké (co se množství týče)\nčásti. Důležitou vlastností mediánu je skutečnost, že není ovlivněn žádnou extrémní hodnotou,\njako je tomu například u průměru.\n\n# Analýza problému\n\n\nExistuje několik způsobů jak daný problém vyřešit. První řešení bude velmi přímočaré. Jedná se\ntotiž o způsob, který zřejmě napadne každého jako první.\n\nPřímočaré řešení\n----------------\n\nToto řešení vlastně ani není tak hledání mediánu jako hledání algoritmicky nejrychlejšího způsobu\njako seřadit danou posloupnost čísel, protože pokud již máme seřazenou posloupnost, stačí zvolit\nprostřední prvek a získáme požadovaný medián. Tento poslední krok můžeme přirozeně vykonat\nse složitostí O(1). Seřadit posloupnost je možné lineárně logaritmickou složitostí O(NlogN) avšak\ns dodatečnou pamětí. Dodatečné paměti je samozřejmě možné se vyhnout, například použitím\nřadicího algoritmu Quicksort, vystavujeme se však nebezpečí kvadratické složitosti v nejhorším\npřípadě.\n\nPři zpětném pohledu je jasné, že nejvíce času strávíme řazením posloupnosti. Přitom řazení\nnebylo v zadání. Je to opravdu nutné? Následující algoritmy uvažují vstupní neseřazenou posloupnost\nstejně jako přímočaré řešení, ale nebudou vynakládat všechen svůj drahocený čas k\nřazení.\n\nAlgoritmus FIND\n---------------\n\nMetoda FIND je mnohem promyšlenější. Využívá techniky \"rozděl a panuj\", což je samo o sobě\nvelmi silná zbraň. FIND se chová velmi podobně jako již zmíněný Quicksort (oba algoritmy vymyslel\nTony Hoare) s tím, že hledá k-té nejmenší číslo, což je pouze zobecnění problému hledání\nmediánu.\n\nPři hledání postupujeme tak, že neseřazenou posloupnost projíždíme zleva, dokud nenalezneme\nprvek, který je větší (nebo roven) než námi zvolený pivot. Poté projíždíme posloupnost\nzprava, dokud nenarazíme na prvek, který je menší (nebo roven) pivotu. V tuto chvíli máme k\ndispozici dva prvky, a oba jsou na špatné straně, takže je prohodíme. V procesu zkoumání výměn\npokračujeme tak dlouho, dokud se nestřetneme. Tím je zajištěno, že jsou menší prvky než pivot\numístěny na levé straně a prvky větší než pivot zase na pravé.\n\nTím však ještě není medián určen, protože pivot byl zvolen (například) náhodně. Můžou\ntotiž nastat tři případy. V nejideálnější situaci je opravdu pivot mediánem a celý proces hledání\nmůžeme úspěšně ukončit. Může se však stát, že pivot nebude uprostřed posloupnosti, tedy byl\nzvolen nešťastně a není mediánem. V tom případě musíme hledat (např. rekurzivně) medián v\nhorní, popř. dolní části posloupnosti v závislosti na umístění aktuálního pivota. Jinak řečeno pokud\nbyl pivot moc malý, upravíme spodní mez posloupnosti. Pokud byl pivot naopak velký,\nupravíme horní mez posloupnosti a cel ý postup opakujeme. Pokud je pivot \"tak akorát\", pak je\nnaším mediánem.\n\nOčekávaný čas metody FIND je 4n, je nutné však připomenout, že je celé hledání založeno na\nQuicksortu, takže může složitost klesnout do kvadratické třídy. Existuje však i lineární řešení viz\nnásledující odstavce.\n\nAlgoritmus SELECT\n-----------------\n\nSELECT je svým chováním velmi podobný metodě FIND, ale dokáže eliminovat problém se\nšpatným zvolením pivota. Postupuje se následovně. Nejdříve rozdělíme neseřazenou posloupnost\nna pět částí s tím, že jedna nemusí být úplná. Následně najdeme medián každé skupiny. Z\nnalezených mediánů najdeme jeden celkový medián. Zde se však nesmíme ukvapit a použít tento\nmedián jako výsledný. Zatím to totiž byl pouze poměrně spolehlivý odhad vhodného pivota pro\ndělení celé posloupnosti.\n\nOpět mohou nastat tři příklady tzn. pivot je rovnou mediánem, pivot je větší, nebo je pivot\nmenší než medián. Při neshodě pivota s mediánem voláme SELECT rekurzivně do té doby,\nnež dostaneme požadovaný prvek. Postup hledání se může zdát dost zamotaný a rekurze na\npřehlednosti nepřidává, nicméně tento algoritmus má složitost O(n).\n\n# Srovnání zmíněných algoritmů\n\n\nHledání mediánu pomocí přímočaré metody vede k seřazení posloupnosti (což nebylo zadáno).\nKromě toho získáme nejlepší složitost O(NlogN), což nemusí být úplně špatné vzhledem k nejhor\nší složitosti Quicksortu O(n^2), ale spotřebujeme více paměti. Oproti tomu algoritmus FIND\nnezabere více paměti než je nutné, jeho složitost však může být také kvadratická. Jednoznačně\nnejlepší řešení se zdá být metoda vyhledávání SELECT, která nejenže nespotřebuje dodatečnou\npaměť, ale navíc si udržuje lineární složitost což je alespoň podle běžně dostupné literatury\nnejlepší možné řešení.\n\n# Závěr\n\n\nNezáleží-li nám na složitosti, nebo paměťové náročnosti, zvolíme přímočarou metodu hledání\nmediánu, která je nejjednodužší na implementaci a pochopení. V opačném případě zvolíme algoritmus\nSELECT, který je sice složitý, ale má vynikající výsledky."
}
