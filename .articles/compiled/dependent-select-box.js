export default {
  "attributes": {
    "id": "420ed8a1-f8bb-42eb-9f8d-356783765357",
    "timestamp": 1414868997000,
    "title": "Dependent select box",
    "slug": "dependent-select-box"
  },
  "body": "Občas je v Nette zapotřebí vyřešit dependent select box. Je to relativně málo častý požadavek a o to méně se o něm dá najít, když je to zrovna potřeba. V zásadě existují dvě řešení. Nudné - poctivé a pak zábavné - špinavé. Podívejme se na to, jak se dá takový dependent select box jednoduše vyřešit.\n\n# Čisté řešení\n\n![](https://zlmlcz-media.s3-eu-west-1.amazonaws.com/51d212f2-5aa9-44b9-9085-f6267e1974e9/vystrizek.png)\nToto řešení ukazuje jak by se takový problém měl zhruba řešit. Myšlenka je velmi jednoduchá. Prvně potřebujeme data do závislého select boxu. Ty se normálně vyřeší prostřednistvím databáze, v našem případě postačí jednoduché pole.\n\n```php\nprivate $database = [\n    [1 => '2', '4', '9'],\n    [4 => '.', '∴', '…'],\n    [5 => 'π', '€', '©'],\n];\n```\n\nNásledně je potřeba vytvořit samotný formulář:\n\n```php\nprotected function createComponentForm($name) {\n    $form = new UI\\Form;\n    $this[$name] = $form; // <- Zde je celý fígl\n    \n    $form->addSelect('one', 'One', ['Čísla', 'Tečky', 'Symboly'])->setDefaultValue(1);\n    //dump($form['one']->value);\n    \n    $form->addSelect('two', 'Two', $this->database[$form['one']->value]);\n    \n    $form->addSubmit('send', 'Odeslat');\n    $form->onSuccess[] = $this->success;\n    return $form;\n}\n```\n\nA k formuláři také šablonu:\n\n```html\n{form form}\n    {input one, size => 3}\n    {snippet two}\n    \t{input two, size => 3}\n    {/snippet}\n    {input send}\n{/form}\n```\n\nAby šlo použít snippet uvnitř formulářového makra, budeme muset udělat malý workaround:\n\n```php\npublic function beforeRender() {\n\tparent::beforeRender();\n\t$this->template->_form = $this['form']; // form {snippet} workaround\n}\n```\n\nSnippet je však možné zatím úplně vynechat, protože bude potřeba až při ajaxifikaci.\n\nCelý fígl je v tom, že musíme zajistit, aby se hodnota druhého select boxu nastavovala podle hodnoty prvního. V tomto stavu je již možné formulář spustit. Po vybrání v prvním select boxu a odeslání formuláře se vybraná hodnota následně projeví v druhém select boxu. Celé kouzlo je pouze v té druhé řádce formulářové továrničky, který mi umožní přistoupit k hodnotám prvků. Je samozřejmě nesmysl odesílat celý formulář pro získání obsahu druhého select boxu, proto si napíšeme krátký javascriptový kód, který to za nás vyřeší (nette.ajax.js):\n\n```javascript\n$(function(){\n\t$.nette.init();\n    \n\t$('select[name=one]').change(function () {\n\t\t$.nette.ajax({\n\t\t\turl: {link invalidate!},\n\t\t\tdata: {\n\t\t\t\t'value': $('select[name=one]').val(),\n\t\t\t}\n\t\t});\n\t});\n});\n```\n\nJakmile se změní hodnota prvního select boxu, zavoláme si handler a předáme mu novou hodnotu. Tento handler bude mít za úkol nastavit hodnoty druhého select boxu a pouze tento prvek invalidovat:\n\n```php\npublic function handleInvalidate($value) {\n\t$this['form']['two']->setItems($this->database[$value]);\n\t$this->redrawControl('two');\n}\n```\n\nTím je vlastně hotovo. Čistotu řešení ověříme tím, že si vyzkoušíme dump vybraných položek po odeslání formuláře:\n\n```php\npublic function success(UI\\Form $form, $vals) {\n\tdump($vals);\n}\n```\n\nČistota spočívá v tom, že požadované hodnoty skutečně získáme. To není úplně samozřejmé, protože v Nette existuje bezpečnostní obranný mechanismus, který zabraňuje odeslání hodnot v select boxu, které na začátku neobsahoval. Pokud něco takového uděláme třeba javascriptem, zíkáme `NULL`. Aby se toto nedělo, musíme takto relativně složitě vyřešit továrničku pro formulář.\n\n# Špinavé řešení\n\nŠpinavé řešení se od toho čisté o moc neliší. Myšlenka je pořád stejná, tentokrát však stojíme před jiným úkolem. Vezměme si příklad, kdy nám zase až tolik nezáleží na tom, jaké získáme v select boxu hodnoty a chceme ho používat spíše jako text input, kdy nabídneme uživateli nějaký vstup. Typický příklad je text input pro URL adresu API, kdy po zadání kontaktujeme nějaké API a nabídneme v selectu vrácené hodnoty tak, aby je uživatel nemusel psát. Netvrdím, že by to nešlo vyřešit čistě, ale špinavé řešení je v tomto případě pohodlnější, rychlejší a mohu na něm ukázat i něco jiného. Tentokrát si vytvoříme úplně obyčejný formulář, tak jako již mnohokrát. Není potřeba žádného fíglu. Opět si připravíme šablonu pro formulář obdobně jako v předchozím případě. A obdobně doplníme nějaký ten javascript. Zde bych klidně mohl formulář upravit javascriptově, ale mě se hodí zavolat si (po napsání URL adresy) handler, v něm vyřešit vše potřebné a invalidovat část formuláře.\n\n```javascript\nvar timer = null;\n$('input[name=url]').live('keyup', function () {\n\tif (timer) {\n\t\tclearTimeout(timer);\n\t}\n\ttimer = setTimeout(function () {\n\t\ttimer = null;\n\t\t$.nette.ajax({\n\t\t\turl: {link checkErp!},\n\t\t\ttype: 'POST',\n\t\t\tdata: {\n\t\t\t\t\"erpForm-url\": $('input[name=url]').val()\n\t\t\t}\n\t\t});\n\t}, 250);\n});\n```\n\nHandler nemá smysl uvádět. Jednoduše v něm vykonám nějakou logiku, vrátím data a invaliduji šablonu. Pozor na to, že předchozí javascriptová ukázka je tentokrát ze separátní komponenty.\n\nZbývá nám vyřešit pouze odeslání a zpracování formuláře. Jelikož jsem byl teď líný programátor a select v tomto případě beru spíše jako text input, nemohu získat hodnotu select boxu ve `$form->getValues()`, resp. v druhém parametru succeeded metody. Musím proto použít metodu `getHttpData`, která mi umožní získat jakákoliv data a zároveň mám jistotu, že jsou data ošetřena:\n\n```php\npublic function erpFormSucceeded(UI\\Form $form, Nette\\Utils\\ArrayHash $values) {\n\ttry {\n\t\t$this->erpSystems->create([\n\t\t\tErpSystems::COLUMN_URL => $values->url,\n\t\t\tErpSystems::COLUMN_DATABASE => $form->getHttpData(UI\\Form::DATA_LINE, 'database'), // <- náš select\n\t\t\tErpSystems::COLUMN_USER => $values->username,\n\t\t\tErpSystems::COLUMN_TOKEN => $values->password,\n\t\t]);\n\t\t//...\n\t} catch (\\PDOException $exc) {\n\t\t//...\n\t}\n\t//...\n}\n```\n\nV tomto špinavém řešení je však zapotřebí myslet na to, že v selectu může přijít naprosto cokoliv. To by však nikoho nemělo převapit. Ostatně i při vytváření formuláře stačí vytvořit select box prázdný, protože žádná vstupní data ani neexistují."
}
