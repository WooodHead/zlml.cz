export default {
  "attributes": {
    "id": "17782730-319b-40ea-92d0-e33c84b32e29",
    "timestamp": 1375215333000,
    "title": "Problémy fulltextu v Nette",
    "slug": "problemy-fulltextu-v-nette"
  },
  "body": "Nedávno jsem psal o tom, jak využívat fulltext indexy na InnoDB tabulkách (http://zlml.cz/using-fulltext-searching-with-innodb).\nNení to nic převratného, ale každý den se to také nedělá. Zmínil jsem také, jak vyhledávat, což\nbylo řešení [Jakuba Vrány .{target:_blank}](http://php.vrana.cz/fulltextove-vyhledavani-v-mysql.php).\n\nV diskusi pod článkem zmíňka o tom, jak ošetřit případ, kdy databáze nevrací výsledky pro slova,\nkterá jsou kratší než je hodnota **ft_min_word_len**. Implementace pro Nette nebude nijak zvlášť\nrozdílná, avšak i zde existuje minimálně jedna zrádnost.\n\n# Nette, ty jedna zrádná bestie...\n\n\nPro dotazování využívám databázovou vrstvu \\Nette\\Database, což je rozšíření (nadstavba) pro PDO.\nS oblibou také využívám fluid zápis a spoléhám na automatické ošetření vstupů. A zde je právě kámen úrazu.\nNette je místy až příliš důkladné (což je dobře), ale v tomto případě to znemožňuje korektní\npoužití **REGEXP**.\n\nBěžný kód pro fultextové dotazování může vypadat takto:\n\n```php\n/** @var Nette\\Database\\SelectionFactory @inject */\npublic $sf;\n    \n$this->sf->table('mirror_posts')\n\t->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)\", $search)\n\t->order(\"5 * MATCH(title) AGAINST (?) + MATCH(body) AGAINST (?) DESC\", $search, $search)\n\t->limit(50);\n```\n\nCož vygeneruje přibližně přesně následující:\n\n```sql\nSELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE)) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nBohužel tento dotaz nevrátí nic. Je to právě kvůli hodnotě **ft_min_word_len**, kterou mám nastavenou\nna 4. Takže můžu změnit tuto hodnotu, a nebo pro všechny slova, která jsou kratší než 4 znaky\nposkládám složitější dotaz:\n\n```php\n$where = \"\";\n//$ft_min_word_len = mysql_result(mysql_query(\"SHOW VARIABLES LIKE 'ft_min_word_len'\"), 0, 1);\n$ft_min_word_len = 4;\npreg_match_all(\"~[\\\\pL\\\\pN_]+('[\\\\pL\\\\pN_]+)*~u\", stripslashes($search), $matches);\nforeach ($matches[0] as $part) {\n\tif (iconv_strlen($part, \"utf-8\") < $ft_min_word_len) {\n\t\t$regexp = \"REGEXP '[[:<:]]\" . addslashes($part) . \"[[:>:]]'\";\n\t\t$where .= \" OR (title $regexp OR body $regexp)\";\n\t}\n}\n```\n\nA doplníme fluidní dotaz:\n\n```php\n...\n->where(\"MATCH(title, body) AGAINST (? IN BOOLEAN MODE)$where\", $search) //přidáno $where\n...\n```\n\nNyní budu vyhledávat stejný výraz a to automaticky poskládaným dotazem:\n\n```sql\nSELECT `id` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE) OR (`title` REGEXP '[[:<:]]`api`[[:>:]]' OR `body` REGEXP '[[:<:]]`api`[[:>:]]')) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nBohužel, ani tento dotaz nevrátí strávný výsledek, ačkoliv se tváří, že by měl.\nDůvodem jsou zpětné uvozovky v regulárním výrazu **''[[:<:]]`api`[[:>:]]''**.\n\nŘešení je zřejmě několik. Například poskládat si tento dotaz sám. Ovšem to není ta nejbezpečnější cesta.\nEscapování je zrádné a zrovna vyhledávání je jedna z nejvíce používaných věcí, kdy se uživatel\npřímo ptá databáze. Existuje však vyčůranější způsob.\n\nCo jsem tak vypozoroval, tak Nette se sice o escapování snaží, ale neescapuje výraz zapsaný pomocí\n<em>strtoupper()</em>. Tzn. že stačí změnit tvorbu výrazu:\n\n```php\n$regexp = \"REGEXP '[[:<:]]\" . addslashes(strtoupper($part)) . \"[[:>:]]'\";\n```\n\nA dotaz se následně poskládá strávně:\n\n```sql\nSELECT `id`, `title`, `body` \nFROM `mirror_posts` \nWHERE (MATCH(`title`, `body`) AGAINST ('api' IN BOOLEAN MODE) OR (`title` REGEXP '[[:<:]]API[[:>:]]' OR `body` REGEXP '[[:<:]]API[[:>:]]')) \nORDER BY 5 * MATCH(`title`) AGAINST ('api') + MATCH(`body`) AGAINST ('api') DESC \nLIMIT 50\n```\n\nTo že je část výrazu jiná než ve skutečnosti nevadí. Nevím jestli je case-insensitive chování\nvlastnost REGEXP, ale tabulkou s postfixem **_ci** se také nic nezkazí.\n\nJen mě tak napadá, proč se to chová tak zvláštně. Uspokojuji se tím, že zpětná uvozovka\nnení úplně součástí escapování, takže se není čeho bát (a první regulár v PHP také nepustí vše),\nale je to divné."
}
