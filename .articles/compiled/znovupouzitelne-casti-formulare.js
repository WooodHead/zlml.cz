export default {
  "attributes": {
    "id": "d0a905ac-329a-46a9-899b-bfe7518519c4",
    "timestamp": 1448405176000,
    "title": "Znovupoužitelné části formuláře",
    "slug": "znovupouzitelne-casti-formulare"
  },
  "body": "Před nějakým časem jsem psal o tom, jak vytvořit [znovupoužitený formulář](znovupouzitelny-formular). Nejedná se o nic jiného, než o správné navržení a následné použití komponent, tedy potomků `UI\\Control`. Pokud bych měl být upřímný, nemyslím si, že se formuláře nějak často na webu opakují a osobně tento princip používám spíše pro oddělení části aplikace do samostatného balíčku. Tím spíš najde následující ukázka méně použití. Právě mám totiž za úkol navrhnout předělání jedné administrace. Úkolem není hledět na to, jak moc je tento přístup špatný, ale navrhnout řešení, které nahradí stávající 1:1. Tato administrace obsahuje často se opakující (a velmi rozsáhlý) formulář, který se skládá z několika karet. Navíc některé části formuláře spolu vůbec nesouvisí a na každé stránce je formulář trošku jiný (i když je podobnost zřejmá). Vzhledem k tomu, že se jedná o tak rozsáhlý kód, upustil jsem od znovupoužitelného formuláře a navrhnul jsem znovupoužitelné pouze jeho části. A na následujících řádcích nastíním jak.\n\n# Na začátku stála komponenta\n\nPořád platí, že je samotný formulář komponenta. Na tom se nic nemění. V mém případě se však hodilo udělat si ještě nějaké bázové třídy. Pokusím se ukázky ořezat co nejvíce od zbytečností tak, aby to pokud možno ještě dávalo smysl:\n\n```php\nclass NewsForm extends BaseControl {\n\n\t/** @var News|NULL */\n\tprivate $news;\n\n\tpublic function __construct($news) {\n\t\tparent::__construct();\n\t\t$this->news = $news;\n\t}\n\n\tpublic function render() {\n\t\t$this->template->render(__DIR__ . '/NewsForm.latte');\n\t}\n\n\tprotected function createComponentNewsForm() {\n\t    $form = $this->form;\n\t    // nastavení společných prvků formuláře\n\t    return $form\n\t}\n\n}\n```\n\nK tomu (třeba) nějaká ta generovaná továrnička a komponenta tak jak ji známe všichni je hotova. Bude však nutné rozklíčovat, co se děje třeba pod třídou `BaseControl`. Jedná se o jednoduchého předka, který krom dalších věcí obsahuje hlavně toto:\n\n```php\nabstract class BaseControl extends UI\\Control {\n\n\t/** @var BaseForm */\n\tprotected $form;\n\n\tpublic function __construct() {\n\t\tparent::__construct();\n\t\t$this->form = new BaseForm;\n\t}\n\n\tprotected function attached($obj) {\n\t\tparent::attached($obj);\n\t\tif ($obj instanceof UI\\Presenter) {\n\t\t\t$this->form->addComponent(new SubmitButtonsContainer, 'submitButtons');\n\t\t\t$this->form->addComponent(new AnotherContainer, 'another');\n\t\t}\n\t}\n\n}\n```\n\nZde se vytvoří nějaký formulář (s kterým pak pracuji v komponentě) a po připojení formuláře k presenteru se připojí i nějaké formulářové kontejnery. Než se však k těmto kontejnerům dostanu, tak by bylo dobré prozradit i co se děje v třídě `BaseForm`. Popravdě nic moc:\n\n```php\n/**\n * @method addTinyMCE($name, $label = NULL, $cols = NULL, $rows = NULL)\n */\nclass BaseForm extends UI\\Form {\n\n\t/** @var callable[] */\n\tpublic $onSaveAndStay;\n\n\t/** @var callable[] */\n\tpublic $onSaveAndExit;\n\n\t/** @var callable[] called BEFORE onClick event */\n\tpublic $onSuccess;\n\n\tpublic function __construct() {\n\t\tparent::__construct();\n\t\t$this->addProtection();\n\t}\n\n}\n```\n\nNastavím si zde nějaké věci, které jsou pro každý formulář v administraci obecně společné. Konkrétně tedy CSRF ochranu a pár polí pro události. Události jsem si zde musel nadefinovat sám, běžně se na formuláři volá `onSuccess` událost až po `onClick` ([link](https://api.nette.org/2.3.7/source-Forms.Form.php.html#380-420)), ale zrovna zde jsem to potřeboval obráceně. Hodí se to v okamžiku, kdy chci využívat `onSuccess`, ale v `onClick` už z formuláře třeba přesměrovávám pryč. Vzhledem k tomu, že oba eventy se volají jen při validním odeslání, tak to ničemu nevadí. V této třídě je také vhodné místo pro umístění nějakých dynamických metod do anotací, aby je IDE dobře napovídalo (viz `addTinyMCE`). Byl to dlouhý úvod, ale vše je připraveno a můžeme se vrhnout na kontejnery.\n\n# Formulářové kontejnery\n\nOsobně [formulářové kontejnery](https://pla.nette.org/cs/dedicnost-vs-kompozice) nemám moc rád. Jsou sice super, ale pohybují se na další úrovni formuláře. Pokud se však s tímto faktem smíříme (a nejlépe z něj uděláme výhodu), pak jsou docela super a zde se skvěle hodí. Můžu si pěkně oddělit například odesílací tlačítka a ty pak vesele používat ve všech formulářích:\n\n```php\nclass SubmitButtonsContainer extends BaseFormContainer {\n\n\tprivate $form;\n\n\tpublic function attached($obj) {\n\t\tparent::attached($obj);\n\t\tif ($obj instanceof BaseForm) {\n\t\t\t$this->form = $obj;\n\t\t\t$obj->onSuccess[] = function (BaseForm $form) {\n\t\t\t\t$path = $this->lookupPath(BaseForm::class);\n\t\t\t\tdump($form->getValues()->$path); // další zpracování hodnot\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic function render() {\n\t\t$this->template->_form = $this; // kvůli formulářovým makrům v šabloně\n\t\t$this->template->render(__DIR__ . '/SubmitButtonsContainer.latte');\n\t}\n\n\tprotected function configure() {\n\t\t$this->addSubmit('saveAndStay', 'Uložit a zůstat')->onClick[] = function (SubmitButton $button) {\n            $form = $button->getForm();\n            $this->form->onSuccess($form, $form->getValues());\n            $this->form->onSaveAndStay($form, $form->getValues());\n\t\t};\n\t}\n\n}\n```\n\nPokud sledujete fórum, tak vám je tento návrh jistě povědomý. Jedná se o [slavné řešení pod čarou](https://forum.nette.org/cs/11747-skladani-komponent-a-formulare#p84652). Přesně toto se odehrává v rodičovské třídě `BaseFormContainer`. Doplnil jsem si do této třídy však jednu malou vychytávku. Chtěl jsem totiž, aby každý kontejner mohl mít vlastní šablonu. To běžně není možné. Kontejner tedy mohu vykreslovat pomocí dobře známého makra `{control ...}` (což nedělá nic jiného, než že se zavolá metoda `render`). Jenže co je `$this->template`? Bázový kontejner jsem musel rozšířit ještě o vhodnou část z `UI\\Control`, která se stará o vykreslování:\n\n```php\nabstract class BaseFormContainer extends Forms\\Container {\n\n\t/** @var UI\\ITemplateFactory */\n\tprivate $templateFactory;\n\n\t/** @var UI\\ITemplate */\n\tprivate $template;\n\n    public function injectTemplateFactory(UI\\ITemplateFactory $templateFactory) {\n\t\t$this->templateFactory = $templateFactory;\n\t}\n\n\tabstract public function render();\n\n    public function getTemplate() {\n\t\t// bla bla, mrkni na: https://api.nette.org/2.3.7/source-Application.UI.Control.php.html#45\n\t\treturn $this->template;\n\t}\n\n\tprotected function createTemplate() {\n\t\t/** @var UI\\ITemplateFactory $templateFactory */\n\t\t$templateFactory = $this->templateFactory ?: $this->lookup(UI\\Presenter::class)->getTemplateFactory();\n\t\treturn $templateFactory->createTemplate(NULL);\n\t}\n```\n\nJednoduché vykreslitelné formulářové kontejnery. Cool. Abych to rychle zrekapituloval. Máme jednoduchou komponentu na formulář, která dědí od `BaseControl`. Tato třída připojuje ve vhodný čas formulářové kontejnery, které se umí vykreslit (což běžně nejde).\n\nV šabloně `SubmitButtonsContainer.latte` je možné používat normálně `{input ...}` makra a další, jako kdybych pokračoval dál v šabloně jednoho velkého formuláře. Samotné připojené formulářové kontejnery je možné vykreslovat pomocí klasického makra `{control newsForm-submitButtons}` v hlavním formuláři. To je možná trošku nevýhoda, protože kontejnery se připojují do formuláře a stávají se tak podkomponentou. Musím tedy control makro volat stylem *rodič-podkomponenta*.\n\n# Znovupoužitelnost vykreslitelných kontejnerů\n\nKde je ta znovupoužitelnost? Jak bych udělal to, že použiju třeba odesílací tlačítka (nebo jakoukoliv jinou část formuláře) někde jinde? Jednoduše. Prostě vytvoříme formulář (to je podmínka nutná) a kontejner v něm použijeme:\n\n```php\nprotected function createComponentTest() {\n    $form = new UI\\Form;\n    $form->addComponent(new AnotherContainer, 'another');\n    $form->addSubmit('odeslat', 'Odeslat');\n    $form->onSuccess[] = function ($_, ArrayHash $values) {\n        dump($values);\n    };\n    return $form;\n}\n```\n\nK tomu třeba nějaká taková šablona:\n\n```\n{form test}\n    {control test-another}\n    {input odeslat}\n{/form}\n```\n\nFormulář se samozřejmě vykreslí i při obyčejném `{control test}`, ale bez šablony kontejneru (píšu si nápad na vylepšení). Vlastně je ta myšlenka docela jednoduchá, že? Jen je třeba dát pozor na to, že kontejner takto umisťuje formulářové prvky na jinou úroveň.\n\nMalá poznámka na závěr, která je sice mimo, ale může se hodit. Občas je potřeba zajistit si někde inject závislostí, ale z nějakého důvodu je to problematické. Může se jednat třeba o závislost v abstraktní rodičovské třídě. V takovém případě je možné v configu nastavit [decorator](https://github.com/dg/nette-di/blob/master/tests/DI/DecoratorExtension.basic.phpt):\n\n```neon\ndecorator:\n\tBaseFormContainer:\n\t\tinject: on\n```\n\n<del>Příště se podíváme znovu na [Dependent select box](dependent-select-box). Původní článek si totiž zaslouží důkladnou revizi a po krátké anketě jsem byl přesvědčen, že bude lepší napsat nový článek a podívat se na celý problém podrobněji.</del> <span style=\"color:green\">Podívejte se raději na <a href=\"https://github.com/NasExt/DependentSelectBox\">tento doplněk</a>, který závislý select box řeší jinak - možná lépe.</span>"
}
