export default {
  "attributes": {
    "id": "c8a25638-706f-4849-8965-d4aa66144ffc",
    "timestamp": 1432200241000,
    "title": "Fixněte si databázi",
    "slug": "fixnete-si-databazi"
  },
  "body": "<p>Možná to znáte. Již nějaký čas nepoužíváte žádný SQL soubor a strukturu databáze si generujete z entit pomocí Doctrine. Je to super, rychlé a funguje to. Paráda. Jenže málokterá databáze se obejde bez nějakých inicializačních dat. Jenže jak na to?</p>\n<h2 id=\"prvn-p-stup\">První přístup <a href=\"#prvn-p-stup\">#</a></h2><p>Nebudu ho popisovat moc dlouho, protože ukazuje přesně to, co nechci ukázat. Jendoduše si napíšete nějaké to SQL, které pak nahrnete do databáze. Třeba nějak takto:</p>\n<pre><code class=\"lang-sql\">REPLACE INTO `options` (`key`, `value`)\nVALUES\n(&#39;option1&#39;, &#39;value1&#39;),\n(&#39;option2&#39;, &#39;value2&#39;),\n(&#39;option3&#39;, &#39;value3&#39;);\n</code></pre>\n<p>To jak si to pošlete do databáze je celkem jedno. Jestli ručně, nebo přes PHP. Pořád někde zůstává SQL. Proč mi to vadí? Tak třeba zde na blogu je nějaká instalace. A protože jsem se ještě nedokopal k tomu to přepsat, tak musím mít tyto soubory dva. Jeden pro MySQL a druhý pro PosgreSQL. <em>(Jo správně, blog jde nainstalovat na více databází...)</em> A to je voser.</p>\n<p>Ale jsou i projekty, kde jsem to udělal rovnou pořádně (i když jsou jen na jedné databázi).</p>\n<h2 id=\"lep-p-stup-pomoc-fixtures\">Lepší přístup pomocí fixtures <a href=\"#lep-p-stup-pomoc-fixtures\">#</a></h2><p>Znáte <a href=\"https://github.com/doctrine/data-fixtures\">Doctrine Data Fixtures Extension</a>? Neznáte? Tak to doporučuji, protože vám pomohou vyřešit přesně tento problém. Lépe tuto knihovnu poznáte pomocí composeru:</p>\n<pre><code>composer require doctrine/data-fixtures\n</code></pre><p>Samozřejmě je takový nepsaný předpoklad, že používáte Doctrine... :) Co dál? Ještě než se pustím do dalšího vysvětlování, bylo by fajn napsat si nějaký command. Na takový command objekt se nejlépe hodí moje oblíbená knihovna <a href=\"https://github.com/Kdyby/Console\">Kdyby/Console</a>, která integruje <a href=\"http://symfony.com/doc/current/components/console/introduction.html\">command ze Symfony</a>. Už jsem o tom psal něco málo <a href=\"kdyby-console\">dříve</a>. A díky této přehršli odkazů již víte jak na to a můžeme rovnou nějaký psát. A protože jsem líný programátor, tak se podívám jak to vyřešil <a href=\"https://github.com/doctrine/DoctrineFixturesBundle/blob/master/Command/LoadDataFixturesDoctrineCommand.php\">někdo jiný</a>. A trošku si to zjedoduším:</p>\n<pre><code class=\"lang-php\">&lt;?php\n\nuse Doctrine\\Common\\DataFixtures\\Executor\\ORMExecutor;\nuse Doctrine\\Common\\DataFixtures\\Loader;\nuse Doctrine\\Common\\DataFixtures\\Purger\\ORMPurger;\nuse Kdyby\\Doctrine\\EntityManager;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass DefaultData extends Command\n{\n\n    /** @var EntityManager @inject */\n    public $em;\n\n    protected function configure()\n    {\n        $this\n            -&gt;setName(&#39;orm:demo-data:load&#39;)\n            -&gt;setDescription(&#39;Load data fixtures to your database.&#39;);\n            //-&gt;addOption...\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        try {\n            $loader = new Loader();\n            $loader-&gt;loadFromDirectory(__DIR__ . &#39;/../basic&#39;);\n            $fixtures = $loader-&gt;getFixtures();\n\n            $purger = new ORMPurger($this-&gt;em);\n\n            $executor = new ORMExecutor($this-&gt;em, $purger);\n            $executor-&gt;setLogger(function ($message) use ($output) {\n                $output-&gt;writeln(sprintf(&#39;  &lt;comment&gt;&gt;&lt;/comment&gt; &lt;info&gt;%s&lt;/info&gt;&#39;, $message));\n            });\n            $executor-&gt;execute($fixtures);\n            return 0; // zero return code means everything is ok\n        } catch (\\Exception $exc) {\n            $output-&gt;writeLn(&quot;&lt;error&gt;{$exc-&gt;getMessage()}&lt;/error&gt;&quot;);\n            return 1; // non-zero return code means error\n        }\n    }\n}\n</code></pre>\n<p>Ok, to jsem to možná ořezal více než je třeba. Mrkněte na tu ukázku pro Symfony, bude to velmi podobné. A teď už konečně k samotným fixture objektům. To jsou ty co načítám ze složky basic pomocí <code>loadFromDirectory</code>. Jedná o objekty, které implementují interface <code>FixtureInterface</code>, nebo možná lépe dědí od abstraktní třídy <code>AbstractFixture</code>. Obojí je v <code>Doctrine\\Common\\DataFixtures</code> namespace. Objekt obsahující defaultní uživatele může vypadat takto:</p>\n<pre><code class=\"lang-php\">&lt;?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse Nette\\Security\\Passwords;\n\nclass UsersFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n    public function load(ObjectManager $manager)\n    {\n        $admin = new \\Users\\User(&#39;admin@nette.org&#39;);\n        $admin-&gt;setPassword(Passwords::hash(&#39;admin&#39;));\n        $admin-&gt;addRole($this-&gt;getReference(&#39;admin-role&#39;));\n        $manager-&gt;persist($admin);\n\n        $demo = new \\Users\\User(&#39;demo@nette.org&#39;);\n        $demo-&gt;setPassword(Passwords::hash(&#39;demo&#39;));\n        $demo-&gt;addRole($this-&gt;getReference(&#39;demo-role&#39;));\n        $manager-&gt;persist($demo);\n\n        $manager-&gt;flush();\n\n        $this-&gt;addReference(&#39;admin-user&#39;, $admin);\n        $this-&gt;addReference(&#39;demo-user&#39;, $demo);\n    }\n\n}\n</code></pre>\n<p>V čem je to tak parádní? Používám PHP kód, používám vlastní nadefinované entity. Hned vidím, že mi to fugnuje, ověřuji svůj návrh databáze a rovnou poskytuji dalším ukázku toho, jak jsem to myslel. Za povšimnutí stojí funkce <code>addReference</code> a <code>getReference</code>. Je jasné, že v každé relační databázi budou nějaké relace a právě k tomu tyto funkce slouží. Vytvořím si tedy nějaké ukazatele a ty pak mohu použít v jiné části demo dat. Lépe to  bude vidět na druhé tabulce:</p>\n<pre><code class=\"lang-php\">&lt;?php\n\nuse Doctrine\\Common\\Persistence\\ObjectManager;\n\nclass RolesFixture extends \\Doctrine\\Common\\DataFixtures\\AbstractFixture\n{\n\n    public function load(ObjectManager $manager)\n    {\n        $user = new \\Users\\Role();\n        $user-&gt;setName(\\Users\\Role::DEMO_USER);\n        $manager-&gt;persist($user);\n\n        $admin = new \\Users\\Role();\n        $admin-&gt;setName(\\Users\\Role::ADMIN);\n        $manager-&gt;persist($admin);\n\n        $manager-&gt;flush();\n\n        $this-&gt;addReference(&#39;demo-role&#39;, $user);\n        $this-&gt;addReference(&#39;admin-role&#39;, $admin);\n    }\n\n}\n</code></pre>\n<p>Vidíte? Mám role, vytvořím si na ně odkaz a používám je při definici uživatele. Vyzkoušejte si to. Uvidíte, jak se krásně naplní referenční tabulky a vše bude tak, jak to má být...</p>\n<p>Jen pozor na jedno věc. Ohlídejte si <a href=\"https://github.com/doctrine/data-fixtures#fixture-ordering\">pořadí těchto objektů</a>. To lze vyřešit implementací rozhraní <code>OrderedFixtureInterface</code>, nebo <code>DependentFixtureInterface</code>, což je o něco lepší přístup.</p>\n<p>A jak toto celé použít? Však už to znáte:</p>\n<pre><code>λ php index.php\nλ php index.php orm:schema-tool:create\nλ php index.php orm:demo-data:load\n</code></pre><p>První příkaz vám nabídne všechny dostupné příkazy, druhý vygeneruje strukturu databáze bez dat a poslední spustí natažení demo dat. Pak už se jen kocháte:</p>\n<pre><code>λ php index.php orm:demo-data:load --demo\nCareful, database will be purged. Do you want to continue Y/N ? y\n  &gt; purging database\n  &gt; loading RolesFixture\n  &gt; loading UsersFixture\n  &gt; loading ArticlesFixture\n  &gt; loading ProductsFixture\n  ...\n</code></pre>"
}
